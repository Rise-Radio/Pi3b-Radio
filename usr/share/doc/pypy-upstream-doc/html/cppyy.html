

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>cppyy: C++ bindings for PyPy &mdash; PyPy 2.2.0 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '2.2.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="PyPy 2.2.0 documentation" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li><a href="index.html">PyPy 2.2.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="cppyy-c-bindings-for-pypy">
<h1>cppyy: C++ bindings for PyPy<a class="headerlink" href="#cppyy-c-bindings-for-pypy" title="Permalink to this headline">¶</a></h1>
<p>The cppyy module creates, at run-time, Python-side classes and functions for
C++, by querying a C++ reflection system.
The default system used is <a class="reference external" href="http://root.cern.ch/drupal/content/reflex">Reflex</a>, which extracts the needed information
from C++ header files.
Another current backend is based on <a class="reference external" href="http://root.cern.ch/drupal/content/cint">CINT</a>, and yet another, more important
one for the medium- to long-term will be based on <a class="reference external" href="http://root.cern.ch/drupal/content/cling">cling</a>.
The latter sits on top of <a class="reference external" href="http://llvm.org/">llvm</a>&#8216;s <a class="reference external" href="http://clang.llvm.org/">clang</a>, and will therefore allow the use
of C++11.
The work on the cling backend has so far been done only for CPython, but
bringing it to PyPy is a lot less work than developing it in the first place.</p>
<p>This document describes the version of cppyy that lives in the main branch of
PyPy.
The development of cppyy happens in the &#8220;reflex-support&#8221; branch.</p>
<div class="section" id="motivation">
<h2>Motivation<a class="headerlink" href="#motivation" title="Permalink to this headline">¶</a></h2>
<p>To provide bindings to another language in CPython, you program to a
generic C-API that exposes many of the interpreter features.
With PyPy, however, there is no such generic C-API, because several of the
interpreter features (e.g. the memory model) are pluggable and therefore
subject to change.
Furthermore, a generic API does not allow any assumptions about the calls
into another language, forcing the JIT to behave conservatively around these
calls and with the objects that cross language boundaries.
In contrast, cppyy does not expose an API, but expects one to be implemented
by a backend.
It makes strong assumptions about the semantics of the API that it uses and
that in turn allows the JIT to make equally strong assumptions.
This is possible, because the expected API is only for providing C++ language
bindings, and does not provide generic programmability.</p>
<p>The cppyy module further offers two features, which result in improved
performance as well as better functionality and cross-language integration.
First, cppyy itself is written in RPython and therefore open to optimizations
by the JIT up until the actual point of call into C++.
This means for example, that if variables are already unboxed by the JIT, they
can be passed through directly to C++.
Second, a backend such as Reflex (and cling far more so) adds dynamic features
to C++, thus greatly reducing impedance mismatches between the two languages.
For example, Reflex is dynamic enough to allow writing runtime bindings
generation in python (as opposed to RPython) and this is used to create very
natural &#8220;pythonizations&#8221; of the bound code.
As another example, cling allows automatic instantiations of templates.</p>
<p>See this description of the <a class="reference external" href="http://morepypy.blogspot.com/2012/06/architecture-of-cppyy.html">cppyy architecture</a> for further details.</p>
</div>
<div class="section" id="installation">
<h2>Installation<a class="headerlink" href="#installation" title="Permalink to this headline">¶</a></h2>
<p>There are two ways of using cppyy, and the choice depends on how pypy-c was
built: the backend can be builtin, or dynamically loadable.
The former has the disadvantage of requiring pypy-c to be linked with external
C++ libraries (e.g. libReflex.so), but has the advantage of being faster in
some cases.
That advantage will disappear over time, however, with improvements in the
JIT.
Therefore, this document assumes that the dynamically loadable backend is
chosen (it is, by default).
See the <a class="reference external" href="cppyy_backend.html">backend documentation</a>.</p>
<p>A standalone version of Reflex that also provides the dynamically loadable
backend is available for <a class="reference external" href="http://cern.ch/wlav/reflex-2013-08-14.tar.bz2">download</a>.
That version, as well as any other distribution of Reflex (e.g. the one that
comes with <a class="reference external" href="http://root.cern.ch/">ROOT</a>, which may be part of your Linux distribution as part of
the selection of scientific software) will also work for a build with the
builtin backend.</p>
<p>Besides Reflex, you probably need a version of <a class="reference external" href="http://www.gccxml.org">gccxml</a> installed, which is
most easily provided by the packager of your system.
If you read up on gccxml, you will probably notice that it is no longer being
developed and hence will not provide C++11 support.
That&#8217;s why the medium term plan is to move to cling.
Note that gccxml is only needed to generate reflection libraries.
It is not needed to use them.</p>
<p>To install the standalone version of Reflex, after download:</p>
<div class="highlight-python"><pre>$ tar jxf reflex-2013-08-14.tar.bz2
$ cd reflex-2013-08-14
$ ./build/autogen
$ ./configure &lt;usual set of options such as --prefix&gt;
$ make &amp;&amp; make install</pre>
</div>
<p>The usual rules apply: &lt;prefix&gt;/bin needs to be added to the <tt class="docutils literal"><span class="pre">PATH</span></tt> and
&lt;prefix&gt;/lib to the <tt class="docutils literal"><span class="pre">LD_LIBRARY_PATH</span></tt> environment variable.
For convenience, this document will assume that there is a <tt class="docutils literal"><span class="pre">REFLEXHOME</span></tt>
variable that points to &lt;prefix&gt;.
If you downloaded or built the whole of ROOT, <tt class="docutils literal"><span class="pre">REFLEXHOME</span></tt> should be equal
to <tt class="docutils literal"><span class="pre">ROOTSYS</span></tt>.</p>
<p>The following is optional, and is only to show how pypy-c can be build
<a class="reference external" href="https://bitbucket.org/pypy/pypy/overview">from source</a>, for example to get at the main development branch of cppyy.
The <a class="reference external" href="cppyy_backend.html">backend documentation</a> has more details on the backend-specific
prerequisites.</p>
<p>Then run the translation to build <tt class="docutils literal"><span class="pre">pypy-c</span></tt>:</p>
<div class="highlight-python"><pre>$ hg clone https://bitbucket.org/pypy/pypy
$ cd pypy
$ hg up reflex-support         # optional

# This example shows python, but using pypy-c is faster and uses less memory
$ python rpython/translator/goal/translate.py --opt=jit pypy/goal/targetpypystandalone --withmod-cppyy</pre>
</div>
<p>This will build a <tt class="docutils literal"><span class="pre">pypy-c</span></tt> that includes the cppyy module, and through that,
Reflex support.
Of course, if you already have a pre-built version of the <tt class="docutils literal"><span class="pre">pypy</span></tt> interpreter,
you can use that for the translation rather than <tt class="docutils literal"><span class="pre">python</span></tt>.
If not, you may want <a class="reference external" href="http://doc.pypy.org/en/latest/getting-started.html#download-a-pre-built-pypy">to obtain a binary distribution</a> to speed up the
translation step.</p>
</div>
<div class="section" id="basic-bindings-example">
<h2>Basic bindings example<a class="headerlink" href="#basic-bindings-example" title="Permalink to this headline">¶</a></h2>
<p>Now test with a trivial example whether all packages are properly installed
and functional.
First, create a C++ header file with some class in it (note that all functions
are made inline for convenience; a real-world example would of course have a
corresponding source file):</p>
<div class="highlight-python"><pre>$ cat MyClass.h
class MyClass {
public:
    MyClass(int i = -99) : m_myint(i) {}

    int GetMyInt() { return m_myint; }
    void SetMyInt(int i) { m_myint = i; }

public:
    int m_myint;
};</pre>
</div>
<p>Then, generate the bindings using <tt class="docutils literal"><span class="pre">genreflex</span></tt> (part of ROOT), and compile the
code:</p>
<div class="highlight-python"><pre>$ genreflex MyClass.h
$ g++ -fPIC -rdynamic -O2 -shared -I$REFLEXHOME/include MyClass_rflx.cpp -o libMyClassDict.so -L$REFLEXHOME/lib -lReflex</pre>
</div>
<p>Next, make sure that the library can be found through the dynamic lookup path
(the <tt class="docutils literal"><span class="pre">LD_LIBRARY_PATH</span></tt> environment variable on Linux, <tt class="docutils literal"><span class="pre">PATH</span></tt> on Windows),
for example by adding &#8221;.&#8221;.
Now you&#8217;re ready to use the bindings.
Since the bindings are designed to look pythonistic, it should be
straightforward:</p>
<div class="highlight-python"><pre>$ pypy-c
&gt;&gt;&gt;&gt; import cppyy
&gt;&gt;&gt;&gt; cppyy.load_reflection_info("libMyClassDict.so")
&lt;CPPLibrary object at 0xb6fd7c4c&gt;
&gt;&gt;&gt;&gt; myinst = cppyy.gbl.MyClass(42)
&gt;&gt;&gt;&gt; print myinst.GetMyInt()
42
&gt;&gt;&gt;&gt; myinst.SetMyInt(33)
&gt;&gt;&gt;&gt; print myinst.m_myint
33
&gt;&gt;&gt;&gt; myinst.m_myint = 77
&gt;&gt;&gt;&gt; print myinst.GetMyInt()
77
&gt;&gt;&gt;&gt; help(cppyy.gbl.MyClass)   # shows that normal python introspection works</pre>
</div>
<p>That&#8217;s all there is to it!</p>
</div>
<div class="section" id="automatic-class-loader">
<h2>Automatic class loader<a class="headerlink" href="#automatic-class-loader" title="Permalink to this headline">¶</a></h2>
<p>There is one big problem in the code above, that prevents its use in a (large
scale) production setting: the explicit loading of the reflection library.
Clearly, if explicit load statements such as these show up in code downstream
from the <tt class="docutils literal"><span class="pre">MyClass</span></tt> package, then that prevents the <tt class="docutils literal"><span class="pre">MyClass</span></tt> author from
repackaging or even simply renaming the dictionary library.</p>
<p>The solution is to make use of an automatic class loader, so that downstream
code never has to call <tt class="docutils literal"><span class="pre">load_reflection_info()</span></tt> directly.
The class loader makes use of so-called rootmap files, which <tt class="docutils literal"><span class="pre">genreflex</span></tt>
can produce.
These files contain the list of available C++ classes and specify the library
that needs to be loaded for their use (as an aside, this listing allows for a
cross-check to see whether reflection info is generated for all classes that
you expect).
By convention, the rootmap files should be located next to the reflection info
libraries, so that they can be found through the normal shared library search
path.
They can be concatenated together, or consist of a single rootmap file per
library.
For example:</p>
<div class="highlight-python"><pre>$ genreflex MyClass.h --rootmap=libMyClassDict.rootmap --rootmap-lib=libMyClassDict.so
$ g++ -fPIC -rdynamic -O2 -shared -I$REFLEXHOME/include MyClass_rflx.cpp -o libMyClassDict.so -L$REFLEXHOME/lib -lReflex</pre>
</div>
<p>where the first option (<tt class="docutils literal"><span class="pre">--rootmap</span></tt>) specifies the output file name, and the
second option (<tt class="docutils literal"><span class="pre">--rootmap-lib</span></tt>) the name of the reflection library where
<tt class="docutils literal"><span class="pre">MyClass</span></tt> will live.
It is necessary to provide that name explicitly, since it is only in the
separate linking step where this name is fixed.
If the second option is not given, the library is assumed to be libMyClass.so,
a name that is derived from the name of the header file.</p>
<p>With the rootmap file in place, the above example can be rerun without explicit
loading of the reflection info library:</p>
<div class="highlight-python"><pre>$ pypy-c
&gt;&gt;&gt;&gt; import cppyy
&gt;&gt;&gt;&gt; myinst = cppyy.gbl.MyClass(42)
&gt;&gt;&gt;&gt; print myinst.GetMyInt()
42
&gt;&gt;&gt;&gt; # etc. ...</pre>
</div>
<p>As a caveat, note that the class loader is currently limited to classes only.</p>
</div>
<div class="section" id="advanced-example">
<h2>Advanced example<a class="headerlink" href="#advanced-example" title="Permalink to this headline">¶</a></h2>
<p>The following snippet of C++ is very contrived, to allow showing that such
pathological code can be handled and to show how certain features play out in
practice:</p>
<div class="highlight-python"><pre>$ cat MyAdvanced.h
#include &lt;string&gt;

class Base1 {
public:
    Base1(int i) : m_i(i) {}
    virtual ~Base1() {}
    int m_i;
};

class Base2 {
public:
    Base2(double d) : m_d(d) {}
    virtual ~Base2() {}
    double m_d;
};

class C;

class Derived : public virtual Base1, public virtual Base2 {
public:
    Derived(const std::string&amp; name, int i, double d) : Base1(i), Base2(d), m_name(name) {}
    virtual C* gimeC() { return (C*)0; }
    std::string m_name;
};

Base2* BaseFactory(const std::string&amp; name, int i, double d) {
    return new Derived(name, i, d);
}</pre>
</div>
<p>This code is still only in a header file, with all functions inline, for
convenience of the example.
If the implementations live in a separate source file or shared library, the
only change needed is to link those in when building the reflection library.</p>
<p>If you were to run <tt class="docutils literal"><span class="pre">genreflex</span></tt> like above in the basic example, you will
find that not all classes of interest will be reflected, nor will be the
global factory function.
In particular, <tt class="docutils literal"><span class="pre">std::string</span></tt> will be missing, since it is not defined in
this header file, but in a header file that is included.
In practical terms, general classes such as <tt class="docutils literal"><span class="pre">std::string</span></tt> should live in a
core reflection set, but for the moment assume we want to have it in the
reflection library that we are building for this example.</p>
<p>The <tt class="docutils literal"><span class="pre">genreflex</span></tt> script can be steered using a so-called <a class="reference external" href="http://root.cern.ch/drupal/content/generating-reflex-dictionaries">selection file</a>,
which is a simple XML file specifying, either explicitly or by using a
pattern, which classes, variables, namespaces, etc. to select from the given
header file.
With the aid of a selection file, a large project can be easily managed:
simply <tt class="docutils literal"><span class="pre">#include</span></tt> all relevant headers into a single header file that is
handed to <tt class="docutils literal"><span class="pre">genreflex</span></tt>.
In fact, if you hand multiple header files to <tt class="docutils literal"><span class="pre">genreflex</span></tt>, then a selection
file is almost obligatory: without it, only classes from the last header will
be selected.
Then, apply a selection file to pick up all the relevant classes.
For our purposes, the following rather straightforward selection will do
(the name <tt class="docutils literal"><span class="pre">lcgdict</span></tt> for the root is historical, but required):</p>
<div class="highlight-python"><pre>$ cat MyAdvanced.xml
&lt;lcgdict&gt;
    &lt;class pattern="Base?" /&gt;
    &lt;class name="Derived" /&gt;
    &lt;class name="std::string" /&gt;
    &lt;function name="BaseFactory" /&gt;
&lt;/lcgdict&gt;</pre>
</div>
<p>Now the reflection info can be generated and compiled:</p>
<div class="highlight-python"><pre>$ genreflex MyAdvanced.h --selection=MyAdvanced.xml
$ g++ -fPIC -rdynamic -O2 -shared -I$REFLEXHOME/include MyAdvanced_rflx.cpp -o libAdvExDict.so -L$REFLEXHOME/lib -lReflex</pre>
</div>
<p>and subsequently be used from PyPy:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="go">&gt;&gt;&gt;&gt; import cppyy</span>
<span class="go">&gt;&gt;&gt;&gt; cppyy.load_reflection_info(&quot;libAdvExDict.so&quot;)</span>
<span class="go">&lt;CPPLibrary object at 0x00007fdb48fc8120&gt;</span>
<span class="go">&gt;&gt;&gt;&gt; d = cppyy.gbl.BaseFactory(&quot;name&quot;, 42, 3.14)</span>
<span class="go">&gt;&gt;&gt;&gt; type(d)</span>
<span class="go">&lt;class &#39;__main__.Derived&#39;&gt;</span>
<span class="go">&gt;&gt;&gt;&gt; isinstance(d, cppyy.gbl.Base1)</span>
<span class="go">True</span>
<span class="go">&gt;&gt;&gt;&gt; isinstance(d, cppyy.gbl.Base2)</span>
<span class="go">True</span>
<span class="go">&gt;&gt;&gt;&gt; d.m_i, d.m_d</span>
<span class="go">(42, 3.14)</span>
<span class="go">&gt;&gt;&gt;&gt; d.m_name == &quot;name&quot;</span>
<span class="go">True</span>
<span class="go">&gt;&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Again, that&#8217;s all there is to it!</p>
<p>A couple of things to note, though.
If you look back at the C++ definition of the <tt class="docutils literal"><span class="pre">BaseFactory</span></tt> function,
you will see that it declares the return type to be a <tt class="docutils literal"><span class="pre">Base2</span></tt>, yet the
bindings return an object of the actual type <tt class="docutils literal"><span class="pre">Derived</span></tt>?
This choice is made for a couple of reasons.
First, it makes method dispatching easier: if bound objects are always their
most derived type, then it is easy to calculate any offsets, if necessary.
Second, it makes memory management easier: the combination of the type and
the memory address uniquely identifies an object.
That way, it can be recycled and object identity can be maintained if it is
entered as a function argument into C++ and comes back to PyPy as a return
value.
Last, but not least, casting is decidedly unpythonistic.
By always providing the most derived type known, casting becomes unnecessary.
For example, the data member of <tt class="docutils literal"><span class="pre">Base2</span></tt> is simply directly available.
Note also that the unreflected <tt class="docutils literal"><span class="pre">gimeC</span></tt> method of <tt class="docutils literal"><span class="pre">Derived</span></tt> does not
preclude its use.
It is only the <tt class="docutils literal"><span class="pre">gimeC</span></tt> method that is unusable as long as class <tt class="docutils literal"><span class="pre">C</span></tt> is
unknown to the system.</p>
</div>
<div class="section" id="features">
<h2>Features<a class="headerlink" href="#features" title="Permalink to this headline">¶</a></h2>
<p>The following is not meant to be an exhaustive list, since cppyy is still
under active development.
Furthermore, the intention is that every feature is as natural as possible on
the python side, so if you find something missing in the list below, simply
try it out.
It is not always possible to provide exact mapping between python and C++
(active memory management is one such case), but by and large, if the use of a
feature does not strike you as obvious, it is more likely to simply be a bug.
That is a strong statement to make, but also a worthy goal.
For the C++ side of the examples, refer to this <a class="reference external" href="cppyy_example.html">example code</a>, which was
bound using:</p>
<div class="highlight-python"><pre>$ genreflex example.h --deep --rootmap=libexampleDict.rootmap --rootmap-lib=libexampleDict.so
$ g++ -fPIC -rdynamic -O2 -shared -I$REFLEXHOME/include example_rflx.cpp -o libexampleDict.so -L$REFLEXHOME/lib -lReflex</pre>
</div>
<ul>
<li><p class="first"><strong>abstract classes</strong>: Are represented as python classes, since they are
needed to complete the inheritance hierarchies, but will raise an exception
if an attempt is made to instantiate from them.
Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="go">&gt;&gt;&gt;&gt; from cppyy.gbl import AbstractClass, ConcreteClass</span>
<span class="go">&gt;&gt;&gt;&gt; a = AbstractClass()</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;console&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">cannot instantiate abstract class &#39;AbstractClass&#39;</span>
<span class="go">&gt;&gt;&gt;&gt; issubclass(ConcreteClass, AbstractClass)</span>
<span class="go">True</span>
<span class="go">&gt;&gt;&gt;&gt; c = ConcreteClass()</span>
<span class="go">&gt;&gt;&gt;&gt; isinstance(c, AbstractClass)</span>
<span class="go">True</span>
<span class="go">&gt;&gt;&gt;&gt;</span>
</pre></div>
</div>
</li>
<li><p class="first"><strong>arrays</strong>: Supported for builtin data types only, as used from module
<tt class="docutils literal"><span class="pre">array</span></tt>.
Out-of-bounds checking is limited to those cases where the size is known at
compile time (and hence part of the reflection info).
Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="go">&gt;&gt;&gt;&gt; from cppyy.gbl import ConcreteClass</span>
<span class="go">&gt;&gt;&gt;&gt; from array import array</span>
<span class="go">&gt;&gt;&gt;&gt; c = ConcreteClass()</span>
<span class="go">&gt;&gt;&gt;&gt; c.array_method(array(&#39;d&#39;, [1., 2., 3., 4.]), 4)</span>
<span class="go">1 2 3 4</span>
<span class="go">&gt;&gt;&gt;&gt;</span>
</pre></div>
</div>
</li>
<li><p class="first"><strong>builtin data types</strong>: Map onto the expected equivalent python types, with
the caveat that there may be size differences, and thus it is possible that
exceptions are raised if an overflow is detected.</p>
</li>
<li><p class="first"><strong>casting</strong>: Is supposed to be unnecessary.
Object pointer returns from functions provide the most derived class known
in the hierarchy of the object being returned.
This is important to preserve object identity as well as to make casting,
a pure C++ feature after all, superfluous.
Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="go">&gt;&gt;&gt;&gt; from cppyy.gbl import AbstractClass, ConcreteClass</span>
<span class="go">&gt;&gt;&gt;&gt; c = ConcreteClass()</span>
<span class="go">&gt;&gt;&gt;&gt; ConcreteClass.show_autocast.__doc__</span>
<span class="go">&#39;AbstractClass* ConcreteClass::show_autocast()&#39;</span>
<span class="go">&gt;&gt;&gt;&gt; d = c.show_autocast()</span>
<span class="go">&gt;&gt;&gt;&gt; type(d)</span>
<span class="go">&lt;class &#39;__main__.ConcreteClass&#39;&gt;</span>
<span class="go">&gt;&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>However, if need be, you can perform C++-style reinterpret_casts (i.e.
without taking offsets into account), by taking and rebinding the address
of an object:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="go">&gt;&gt;&gt;&gt; from cppyy import addressof, bind_object</span>
<span class="go">&gt;&gt;&gt;&gt; e = bind_object(addressof(d), AbstractClass)</span>
<span class="go">&gt;&gt;&gt;&gt; type(e)</span>
<span class="go">&lt;class &#39;__main__.AbstractClass&#39;&gt;</span>
<span class="go">&gt;&gt;&gt;&gt;</span>
</pre></div>
</div>
</li>
<li><p class="first"><strong>classes and structs</strong>: Get mapped onto python classes, where they can be
instantiated as expected.
If classes are inner classes or live in a namespace, their naming and
location will reflect that.
Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="go">&gt;&gt;&gt;&gt; from cppyy.gbl import ConcreteClass, Namespace</span>
<span class="go">&gt;&gt;&gt;&gt; ConcreteClass == Namespace.ConcreteClass</span>
<span class="go">False</span>
<span class="go">&gt;&gt;&gt;&gt; n = Namespace.ConcreteClass.NestedClass()</span>
<span class="go">&gt;&gt;&gt;&gt; type(n)</span>
<span class="go">&lt;class &#39;__main__.Namespace::ConcreteClass::NestedClass&#39;&gt;</span>
<span class="go">&gt;&gt;&gt;&gt;</span>
</pre></div>
</div>
</li>
<li><p class="first"><strong>data members</strong>: Public data members are represented as python properties
and provide read and write access on instances as expected.
Private and protected data members are not accessible.
Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="go">&gt;&gt;&gt;&gt; from cppyy.gbl import ConcreteClass</span>
<span class="go">&gt;&gt;&gt;&gt; c = ConcreteClass()</span>
<span class="go">&gt;&gt;&gt;&gt; c.m_int</span>
<span class="go">42</span>
<span class="go">&gt;&gt;&gt;&gt;</span>
</pre></div>
</div>
</li>
<li><p class="first"><strong>default arguments</strong>: C++ default arguments work as expected, but python
keywords are not supported.
It is technically possible to support keywords, but for the C++ interface,
the formal argument names have no meaning and are not considered part of the
API, hence it is not a good idea to use keywords.
Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="go">&gt;&gt;&gt;&gt; from cppyy.gbl import ConcreteClass</span>
<span class="go">&gt;&gt;&gt;&gt; c = ConcreteClass()       # uses default argument</span>
<span class="go">&gt;&gt;&gt;&gt; c.m_int</span>
<span class="go">42</span>
<span class="go">&gt;&gt;&gt;&gt; c = ConcreteClass(13)</span>
<span class="go">&gt;&gt;&gt;&gt; c.m_int</span>
<span class="go">13</span>
<span class="go">&gt;&gt;&gt;&gt;</span>
</pre></div>
</div>
</li>
<li><p class="first"><strong>doc strings</strong>: The doc string of a method or function contains the C++
arguments and return types of all overloads of that name, as applicable.
Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="go">&gt;&gt;&gt;&gt; from cppyy.gbl import ConcreteClass</span>
<span class="go">&gt;&gt;&gt;&gt; print ConcreteClass.array_method.__doc__</span>
<span class="go">void ConcreteClass::array_method(int*, int)</span>
<span class="go">void ConcreteClass::array_method(double*, int)</span>
<span class="go">&gt;&gt;&gt;&gt;</span>
</pre></div>
</div>
</li>
<li><p class="first"><strong>enums</strong>: Are translated as ints with no further checking.</p>
</li>
<li><p class="first"><strong>functions</strong>: Work as expected and live in their appropriate namespace
(which can be the global one, <tt class="docutils literal"><span class="pre">cppyy.gbl</span></tt>).</p>
</li>
<li><p class="first"><strong>inheritance</strong>: All combinations of inheritance on the C++ (single,
multiple, virtual) are supported in the binding.
However, new python classes can only use single inheritance from a bound C++
class.
Multiple inheritance would introduce two &#8220;this&#8221; pointers in the binding.
This is a current, not a fundamental, limitation.
The C++ side will not see any overridden methods on the python side, as
cross-inheritance is planned but not yet supported.
Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="go">&gt;&gt;&gt;&gt; from cppyy.gbl import ConcreteClass</span>
<span class="go">&gt;&gt;&gt;&gt; help(ConcreteClass)</span>
<span class="go">Help on class ConcreteClass in module __main__:</span>

<span class="go">class ConcreteClass(AbstractClass)</span>
<span class="go"> |  Method resolution order:</span>
<span class="go"> |      ConcreteClass</span>
<span class="go"> |      AbstractClass</span>
<span class="go"> |      cppyy.CPPObject</span>
<span class="go"> |      __builtin__.CPPInstance</span>
<span class="go"> |      __builtin__.object</span>
<span class="go"> |</span>
<span class="go"> |  Methods defined here:</span>
<span class="go"> |</span>
<span class="go"> |  ConcreteClass(self, *args)</span>
<span class="go"> |      ConcreteClass::ConcreteClass(const ConcreteClass&amp;)</span>
<span class="go"> |      ConcreteClass::ConcreteClass(int)</span>
<span class="go"> |      ConcreteClass::ConcreteClass()</span>
<span class="go"> |</span>
<span class="go"> etc. ....</span>
</pre></div>
</div>
</li>
<li><p class="first"><strong>memory</strong>: C++ instances created by calling their constructor from python
are owned by python.
You can check/change the ownership with the _python_owns flag that every
bound instance carries.
Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="go">&gt;&gt;&gt;&gt; from cppyy.gbl import ConcreteClass</span>
<span class="go">&gt;&gt;&gt;&gt; c = ConcreteClass()</span>
<span class="go">&gt;&gt;&gt;&gt; c._python_owns            # True: object created in Python</span>
<span class="go">True</span>
<span class="go">&gt;&gt;&gt;&gt;</span>
</pre></div>
</div>
</li>
<li><p class="first"><strong>methods</strong>: Are represented as python methods and work as expected.
They are first class objects and can be bound to an instance.
Virtual C++ methods work as expected.
To select a specific virtual method, do like with normal python classes
that override methods: select it from the class that you need, rather than
calling the method on the instance.
To select a specific overload, use the __dispatch__ special function, which
takes the name of the desired method and its signature (which can be
obtained from the doc string) as arguments.</p>
</li>
<li><p class="first"><strong>namespaces</strong>: Are represented as python classes.
Namespaces are more open-ended than classes, so sometimes initial access may
result in updates as data and functions are looked up and constructed
lazily.
Thus the result of <tt class="docutils literal"><span class="pre">dir()</span></tt> on a namespace shows the classes available,
even if they may not have been created yet.
It does not show classes that could potentially be loaded by the class
loader.
Once created, namespaces are registered as modules, to allow importing from
them.
Namespace currently do not work with the class loader.
Fixing these bootstrap problems is on the TODO list.
The global namespace is <tt class="docutils literal"><span class="pre">cppyy.gbl</span></tt>.</p>
</li>
<li><p class="first"><strong>operator conversions</strong>: If defined in the C++ class and a python
equivalent exists (i.e. all builtin integer and floating point types, as well
as <tt class="docutils literal"><span class="pre">bool</span></tt>), it will map onto that python conversion.
Note that <tt class="docutils literal"><span class="pre">char*</span></tt> is mapped onto <tt class="docutils literal"><span class="pre">__str__</span></tt>.
Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="go">&gt;&gt;&gt;&gt; from cppyy.gbl import ConcreteClass</span>
<span class="go">&gt;&gt;&gt;&gt; print ConcreteClass()</span>
<span class="go">Hello operator const char*!</span>
<span class="go">&gt;&gt;&gt;&gt;</span>
</pre></div>
</div>
</li>
<li><p class="first"><strong>operator overloads</strong>: If defined in the C++ class and if a python
equivalent is available (not always the case, think e.g. of <tt class="docutils literal"><span class="pre">operator||</span></tt>),
then they work as expected.
Special care needs to be taken for global operator overloads in C++: first,
make sure that they are actually reflected, especially for the global
overloads for <tt class="docutils literal"><span class="pre">operator==</span></tt> and <tt class="docutils literal"><span class="pre">operator!=</span></tt> of STL vector iterators in
the case of gcc (note that they are not needed to iterator over a vector).
Second, make sure that reflection info is loaded in the proper order.
I.e. that these global overloads are available before use.</p>
</li>
<li><p class="first"><strong>pointers</strong>: For builtin data types, see arrays.
For objects, a pointer to an object and an object looks the same, unless
the pointer is a data member.
In that case, assigning to the data member will cause a copy of the pointer
and care should be taken about the object&#8217;s life time.
If a pointer is a global variable, the C++ side can replace the underlying
object and the python side will immediately reflect that.</p>
</li>
<li><p class="first"><strong>PyObject*</strong>: Arguments and return types of <tt class="docutils literal"><span class="pre">PyObject*</span></tt> can be used, and
passed on to CPython API calls.
Since these CPython-like objects need to be created and tracked (this all
happens through <tt class="docutils literal"><span class="pre">cpyext</span></tt>) this interface is not particularly fast.</p>
</li>
<li><p class="first"><strong>static data members</strong>: Are represented as python property objects on the
class and the meta-class.
Both read and write access is as expected.</p>
</li>
<li><p class="first"><strong>static methods</strong>: Are represented as python&#8217;s <tt class="docutils literal"><span class="pre">staticmethod</span></tt> objects
and can be called both from the class as well as from instances.</p>
</li>
<li><p class="first"><strong>strings</strong>: The std::string class is considered a builtin C++ type and
mixes quite well with python&#8217;s str.
Python&#8217;s str can be passed where a <tt class="docutils literal"><span class="pre">const</span> <span class="pre">char*</span></tt> is expected, and an str
will be returned if the return type is <tt class="docutils literal"><span class="pre">const</span> <span class="pre">char*</span></tt>.</p>
</li>
<li><p class="first"><strong>templated classes</strong>: Are represented in a meta-class style in python.
This may look a little bit confusing, but conceptually is rather natural.
For example, given the class <tt class="docutils literal"><span class="pre">std::vector&lt;int&gt;</span></tt>, the meta-class part would
be <tt class="docutils literal"><span class="pre">std.vector</span></tt>.
Then, to get the instantiation on <tt class="docutils literal"><span class="pre">int</span></tt>, do <tt class="docutils literal"><span class="pre">std.vector(int)</span></tt> and to
create an instance of that class, do <tt class="docutils literal"><span class="pre">std.vector(int)()</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="go">&gt;&gt;&gt;&gt; import cppyy</span>
<span class="go">&gt;&gt;&gt;&gt; cppyy.load_reflection_info(&#39;libexampleDict.so&#39;)</span>
<span class="go">&gt;&gt;&gt;&gt; cppyy.gbl.std.vector                # template metatype</span>
<span class="go">&lt;cppyy.CppyyTemplateType object at 0x00007fcdd330f1a0&gt;</span>
<span class="go">&gt;&gt;&gt;&gt; cppyy.gbl.std.vector(int)           # instantiates template -&gt; class</span>
<span class="go">&lt;class &#39;__main__.std::vector&lt;int&gt;&#39;&gt;</span>
<span class="go">&gt;&gt;&gt;&gt; cppyy.gbl.std.vector(int)()         # instantiates class -&gt; object</span>
<span class="go">&lt;__main__.std::vector&lt;int&gt; object at 0x00007fe480ba4bc0&gt;</span>
<span class="go">&gt;&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Note that templates can be build up by handing actual types to the class
instantiation (as done in this vector example), or by passing in the list of
template arguments as a string.
The former is a lot easier to work with if you have template instantiations
using classes that themselves are templates in  the arguments (think e.g a
vector of vectors).
All template classes must already exist in the loaded reflection info, they
do not work (yet) with the class loader.</p>
<p>For compatibility with other bindings generators, use of square brackets
instead of parenthesis to instantiate templates is supported as well.</p>
</li>
<li><p class="first"><strong>templated functions</strong>: Automatically participate in overloading and are
used in the same way as other global functions.</p>
</li>
<li><p class="first"><strong>templated methods</strong>: For now, require an explicit selection of the
template parameters.
This will be changed to allow them to participate in overloads as expected.</p>
</li>
<li><p class="first"><strong>typedefs</strong>: Are simple python references to the actual classes to which
they refer.</p>
</li>
<li><p class="first"><strong>unary operators</strong>: Are supported if a python equivalent exists, and if the
operator is defined in the C++ class.</p>
</li>
</ul>
<p>You can always find more detailed examples and see the full of supported
features by looking at the tests in pypy/module/cppyy/test.</p>
<p>If a feature or reflection info is missing, this is supposed to be handled
gracefully.
In fact, there are unit tests explicitly for this purpose (even as their use
becomes less interesting over time, as the number of missing features
decreases).
Only when a missing feature is used, should there be an exception.
For example, if no reflection info is available for a return type, then a
class that has a method with that return type can still be used.
Only that one specific method can not be used.</p>
</div>
<div class="section" id="templates">
<h2>Templates<a class="headerlink" href="#templates" title="Permalink to this headline">¶</a></h2>
<p>A bit of special care needs to be taken for the use of templates.
For a templated class to be completely available, it must be guaranteed that
said class is fully instantiated, and hence all executable C++ code is
generated and compiled in.
The easiest way to fulfill that guarantee is by explicit instantiation in the
header file that is handed to <tt class="docutils literal"><span class="pre">genreflex</span></tt>.
The following example should make that clear:</p>
<div class="highlight-python"><pre>$ cat MyTemplate.h
#include &lt;vector&gt;

class MyClass {
public:
    MyClass(int i = -99) : m_i(i) {}
    MyClass(const MyClass&amp; s) : m_i(s.m_i) {}
    MyClass&amp; operator=(const MyClass&amp; s) { m_i = s.m_i; return *this; }
    ~MyClass() {}
    int m_i;
};

#ifdef __GCCXML__
template class std::vector&lt;MyClass&gt;;   // explicit instantiation
#endif</pre>
</div>
<p>If you know for certain that all symbols will be linked in from other sources,
you can also declare the explicit template instantiation <tt class="docutils literal"><span class="pre">extern</span></tt>.
An alternative is to add an object to an unnamed namespace:</p>
<div class="highlight-python"><pre>namespace {
    std::vector&lt;MyClass&gt; vmc;
} // unnamed namespace</pre>
</div>
<p>Unfortunately, this is not always enough for gcc.
The iterators of vectors, if they are going to be used, need to be
instantiated as well, as do the comparison operators on those iterators, as
these live in an internal namespace, rather than in the iterator classes.
Note that you do NOT need this iterators to iterator over a vector.
You only need them if you plan to explicitly call e.g. <tt class="docutils literal"><span class="pre">begin</span></tt> and <tt class="docutils literal"><span class="pre">end</span></tt>
methods, and do comparisons of iterators.
One way to handle this, is to deal with this once in a macro, then reuse that
macro for all <tt class="docutils literal"><span class="pre">vector</span></tt> classes.
Thus, the header above needs this (again protected with
<tt class="docutils literal"><span class="pre">#ifdef</span> <span class="pre">__GCCXML__</span></tt>), instead of just the explicit instantiation of the
<tt class="docutils literal"><span class="pre">vector&lt;MyClass&gt;</span></tt>:</p>
<div class="highlight-python"><pre>#define STLTYPES_EXPLICIT_INSTANTIATION_DECL(STLTYPE, TTYPE)                      \
template class std::STLTYPE&lt; TTYPE &gt;;                                             \
template class __gnu_cxx::__normal_iterator&lt;TTYPE*, std::STLTYPE&lt; TTYPE &gt; &gt;;      \
template class __gnu_cxx::__normal_iterator&lt;const TTYPE*, std::STLTYPE&lt; TTYPE &gt; &gt;;\
namespace __gnu_cxx {                                                             \
template bool operator==(const std::STLTYPE&lt; TTYPE &gt;::iterator&amp;,                  \
                         const std::STLTYPE&lt; TTYPE &gt;::iterator&amp;);                 \
template bool operator!=(const std::STLTYPE&lt; TTYPE &gt;::iterator&amp;,                  \
                         const std::STLTYPE&lt; TTYPE &gt;::iterator&amp;);                 \
}

STLTYPES_EXPLICIT_INSTANTIATION_DECL(vector, MyClass)</pre>
</div>
<p>Then, still for gcc, the selection file needs to contain the full hierarchy as
well as the global overloads for comparisons for the iterators:</p>
<div class="highlight-python"><pre>$ cat MyTemplate.xml
&lt;lcgdict&gt;
    &lt;class pattern="std::vector&lt;*&gt;" /&gt;
    &lt;class pattern="std::vector&lt;*&gt;::iterator" /&gt;
    &lt;function name="__gnu_cxx::operator=="/&gt;
    &lt;function name="__gnu_cxx::operator!="/&gt;

    &lt;class name="MyClass" /&gt;
&lt;/lcgdict&gt;</pre>
</div>
<p>Run the normal <tt class="docutils literal"><span class="pre">genreflex</span></tt> and compilation steps:</p>
<div class="highlight-python"><pre>$ genreflex MyTemplate.h --selection=MyTemplate.xml
$ g++ -fPIC -rdynamic -O2 -shared -I$REFLEXHOME/include MyTemplate_rflx.cpp -o libTemplateDict.so -L$REFLEXHOME/lib -lReflex</pre>
</div>
<p>Note: this is a dirty corner that clearly could do with some automation,
even if the macro already helps.
Such automation is planned.
In fact, in the Cling world, the backend can perform the template
instantations and generate the reflection info on the fly, and none of the
above will any longer be necessary.</p>
<p>Subsequent use should be as expected.
Note the meta-class style of &#8220;instantiating&#8221; the template:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="go">&gt;&gt;&gt;&gt; import cppyy</span>
<span class="go">&gt;&gt;&gt;&gt; cppyy.load_reflection_info(&quot;libTemplateDict.so&quot;)</span>
<span class="go">&gt;&gt;&gt;&gt; std = cppyy.gbl.std</span>
<span class="go">&gt;&gt;&gt;&gt; MyClass = cppyy.gbl.MyClass</span>
<span class="go">&gt;&gt;&gt;&gt; v = std.vector(MyClass)()</span>
<span class="go">&gt;&gt;&gt;&gt; v += [MyClass(1), MyClass(2), MyClass(3)]</span>
<span class="go">&gt;&gt;&gt;&gt; for m in v:</span>
<span class="go">....     print m.m_i,</span>
<span class="go">....</span>
<span class="go">1 2 3</span>
<span class="go">&gt;&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Other templates work similarly, but are typically simpler, as there are no
similar issues with iterators for e.g. <tt class="docutils literal"><span class="pre">std::list</span></tt>.
The arguments to the template instantiation can either be a string with the
full list of arguments, or the explicit classes.
The latter makes for easier code writing if the classes passed to the
instantiation are themselves templates.</p>
</div>
<div class="section" id="the-fast-lane">
<h2>The fast lane<a class="headerlink" href="#the-fast-lane" title="Permalink to this headline">¶</a></h2>
<p>The following is an experimental feature of cppyy.
It mostly works, but there are some known issues (e.g. with return-by-value).
Soon it should be the default mode, however.</p>
<p>With a slight modification of Reflex, it can provide function pointers for
C++ methods, and hence allow PyPy to call those pointers directly, rather than
calling C++ through a Reflex stub.</p>
<p>The standalone version of Reflex <a class="reference external" href="http://cern.ch/wlav/reflex-2013-04-23.tar.bz2">provided</a> has been patched, but if you get
Reflex from another source (most likely with a ROOT distribution), locate the
file <a class="reference external" href="https://bitbucket.org/pypy/pypy/src/default/pypy/module/cppyy/genreflex-methptrgetter.patch">genreflex-methptrgetter.patch</a> in pypy/module/cppyy and apply it to
the genreflex python scripts found in <tt class="docutils literal"><span class="pre">$ROOTSYS/lib</span></tt>:</p>
<div class="highlight-python"><pre>$ cd $ROOTSYS/lib
$ patch -p2 &lt; genreflex-methptrgetter.patch</pre>
</div>
<p>With this patch, <tt class="docutils literal"><span class="pre">genreflex</span></tt> will have grown the <tt class="docutils literal"><span class="pre">--with-methptrgetter</span></tt>
option.
Use this option when running <tt class="docutils literal"><span class="pre">genreflex</span></tt>, and add the
<tt class="docutils literal"><span class="pre">-Wno-pmf-conversions</span></tt> option to <tt class="docutils literal"><span class="pre">g++</span></tt> when compiling.
The rest works the same way: the fast path will be used transparently (which
also means that you can&#8217;t actually find out whether it is in use, other than
by running a micro-benchmark or a JIT test).</p>
</div>
<div class="section" id="cpython">
<h2>CPython<a class="headerlink" href="#cpython" title="Permalink to this headline">¶</a></h2>
<p>Most of the ideas in cppyy come originally from the <a class="reference external" href="http://root.cern.ch/drupal/content/pyroot">PyROOT</a> project.
Although PyROOT does not support Reflex directly, it has an alter ego called
&#8220;PyCintex&#8221; that, in a somewhat roundabout way, does.
If you installed ROOT, rather than just Reflex, PyCintex should be available
immediately if you add <tt class="docutils literal"><span class="pre">$ROOTSYS/lib</span></tt> to the <tt class="docutils literal"><span class="pre">PYTHONPATH</span></tt> environment
variable.</p>
<p>There are a couple of minor differences between PyCintex and cppyy, most to do
with naming.
The one that you will run into directly, is that PyCintex uses a function
called <tt class="docutils literal"><span class="pre">loadDictionary</span></tt> rather than <tt class="docutils literal"><span class="pre">load_reflection_info</span></tt> (it has the
same rootmap-based class loader functionality, though, making this point
somewhat moot).
The reason for this is that Reflex calls the shared libraries that contain
reflection info &#8220;dictionaries.&#8221;
However, in python, the name <cite>dictionary</cite> already has a well-defined meaning,
so a more descriptive name was chosen for cppyy.
In addition, PyCintex requires that the names of shared libraries so loaded
start with &#8220;lib&#8221; in their name.
The basic example above, rewritten for PyCintex thus goes like this:</p>
<div class="highlight-python"><pre>$ python
&gt;&gt;&gt; import PyCintex
&gt;&gt;&gt; PyCintex.loadDictionary("libMyClassDict.so")
&gt;&gt;&gt; myinst = PyCintex.gbl.MyClass(42)
&gt;&gt;&gt; print myinst.GetMyInt()
42
&gt;&gt;&gt; myinst.SetMyInt(33)
&gt;&gt;&gt; print myinst.m_myint
33
&gt;&gt;&gt; myinst.m_myint = 77
&gt;&gt;&gt; print myinst.GetMyInt()
77
&gt;&gt;&gt; help(PyCintex.gbl.MyClass)   # shows that normal python introspection works</pre>
</div>
<p>Other naming differences are such things as taking an address of an object.
In PyCintex, this is done with <tt class="docutils literal"><span class="pre">AddressOf</span></tt> whereas in cppyy the choice was
made to follow the naming as in <tt class="docutils literal"><span class="pre">ctypes</span></tt> and hence use <tt class="docutils literal"><span class="pre">addressof</span></tt>
(PyROOT/PyCintex predate <tt class="docutils literal"><span class="pre">ctypes</span></tt> by several years, and the ROOT project
follows camel-case, hence the differences).</p>
<p>Of course, this is python, so if any of the naming is not to your liking, all
you have to do is provide a wrapper script that you import instead of
importing the <tt class="docutils literal"><span class="pre">cppyy</span></tt> or <tt class="docutils literal"><span class="pre">PyCintex</span></tt> modules directly.
In that wrapper script you can rename methods exactly the way you need it.</p>
<p>In the cling world, all these differences will be resolved.</p>
</div>
<div class="section" id="python3">
<h2>Python3<a class="headerlink" href="#python3" title="Permalink to this headline">¶</a></h2>
<p>To change versions of CPython (to Python3, another version of Python, or later
to the <a class="reference external" href="https://bitbucket.org/pypy/pypy/src/py3k">Py3k</a> version of PyPy), the only part that requires recompilation is
the bindings module, be it <tt class="docutils literal"><span class="pre">cppyy</span></tt> or <tt class="docutils literal"><span class="pre">libPyROOT.so</span></tt> (in PyCintex).
Although <tt class="docutils literal"><span class="pre">genreflex</span></tt> is indeed a Python tool, the generated reflection
information is completely independent of Python.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">cppyy: C++ bindings for PyPy</a><ul>
<li><a class="reference internal" href="#motivation">Motivation</a></li>
<li><a class="reference internal" href="#installation">Installation</a></li>
<li><a class="reference internal" href="#basic-bindings-example">Basic bindings example</a></li>
<li><a class="reference internal" href="#automatic-class-loader">Automatic class loader</a></li>
<li><a class="reference internal" href="#advanced-example">Advanced example</a></li>
<li><a class="reference internal" href="#features">Features</a></li>
<li><a class="reference internal" href="#templates">Templates</a></li>
<li><a class="reference internal" href="#the-fast-lane">The fast lane</a></li>
<li><a class="reference internal" href="#cpython">CPython</a></li>
<li><a class="reference internal" href="#python3">Python3</a></li>
</ul>
</li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/cppyy.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li><a href="index.html">PyPy 2.2.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, The PyPy Project.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>