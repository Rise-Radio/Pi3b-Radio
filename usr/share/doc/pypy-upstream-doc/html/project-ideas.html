

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Potential project list &mdash; PyPy 2.2.0 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '2.2.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="PyPy 2.2.0 documentation" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li><a href="index.html">PyPy 2.2.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="potential-project-list">
<h1>Potential project list<a class="headerlink" href="#potential-project-list" title="Permalink to this headline">¶</a></h1>
<p>This is a list of projects that are interesting for potential contributors
who are seriously interested in the PyPy project. They mostly share common
patterns - they&#8217;re mid-to-large in size, they&#8217;re usually well defined as
a standalone projects and they&#8217;re not being actively worked on. For small
projects that you might want to work on, it&#8217;s much better to either look
at the <a class="reference external" href="http://bugs.pypy.org">issue tracker</a>, pop up on #pypy on irc.freenode.net or write to the
<a class="reference external" href="http://mail.python.org/mailman/listinfo/pypy-dev">mailing list</a>. This is simply for the reason that small possible projects
tend to change very rapidly.</p>
<p>This list is mostly for having on overview on potential projects. This list is
by definition not exhaustive and we&#8217;re pleased if people come up with their
own improvement ideas. In any case, if you feel like working on some of those
projects, or anything else in PyPy, pop up on IRC or write to us on the
<a class="reference external" href="http://mail.python.org/mailman/listinfo/pypy-dev">mailing list</a>.</p>
<div class="section" id="make-bytearray-type-fast">
<h2>Make bytearray type fast<a class="headerlink" href="#make-bytearray-type-fast" title="Permalink to this headline">¶</a></h2>
<p>PyPy&#8217;s bytearray type is very inefficient. It would be an interesting
task to look into possible optimizations on this.</p>
</div>
<div class="section" id="implement-copy-on-write-list-slicing">
<h2>Implement copy-on-write list slicing<a class="headerlink" href="#implement-copy-on-write-list-slicing" title="Permalink to this headline">¶</a></h2>
<p>The idea is to have a special implementation of list objects which is used
when doing <tt class="docutils literal"><span class="pre">myslice</span> <span class="pre">=</span> <span class="pre">mylist[a:b]</span></tt>: the new list is not constructed
immediately, but only when (and if) <tt class="docutils literal"><span class="pre">myslice</span></tt> or <tt class="docutils literal"><span class="pre">mylist</span></tt> are mutated.</p>
</div>
<div class="section" id="numpy-improvements">
<h2>Numpy improvements<a class="headerlink" href="#numpy-improvements" title="Permalink to this headline">¶</a></h2>
<p>The numpy is rapidly progressing in pypy, so feel free to come to IRC and
ask for proposed topic. A not necesarilly up-to-date <a class="reference external" href="https://bitbucket.org/pypy/extradoc/src/extradoc/planning/micronumpy.txt">list of topics</a>
is also available.</p>
</div>
<div class="section" id="improving-the-jitviewer">
<h2>Improving the jitviewer<a class="headerlink" href="#improving-the-jitviewer" title="Permalink to this headline">¶</a></h2>
<p>Analyzing performance of applications is always tricky. We have various
tools, for example a <a class="reference external" href="http://bitbucket.org/pypy/jitviewer">jitviewer</a> that help us analyze performance.</p>
<p>The jitviewer shows the code generated by the PyPy JIT in a hierarchical way,
as shown by the screenshot below:</p>
<blockquote>
<div><ul class="simple">
<li>at the bottom level, it shows the Python source code of the compiled loops</li>
<li>for each source code line, it shows the corresponding Python bytecode</li>
<li>for each opcode, it shows the corresponding jit operations, which are the
ones actually sent to the backend for compiling (such as <tt class="docutils literal"><span class="pre">i15</span> <span class="pre">=</span> <span class="pre">i10</span> <span class="pre">&lt;</span>
<span class="pre">2000</span></tt> in the example)</li>
</ul>
</div></blockquote>
<img alt="_images/jitviewer.png" src="_images/jitviewer.png" />
<p>The jitviewer is a web application based on flask and jinja2 (and jQuery on
the client): if you have great web developing skills and want to help PyPy,
this is an ideal task to get started, because it does not require any deep
knowledge of the internals.</p>
</div>
<div class="section" id="optimized-unicode-representation">
<h2>Optimized Unicode Representation<a class="headerlink" href="#optimized-unicode-representation" title="Permalink to this headline">¶</a></h2>
<p>CPython 3.3 will use an <a class="reference external" href="http://www.python.org/dev/peps/pep-0393/">optimized unicode representation</a> which switches between
different ways to represent a unicode string, depending on whether the string
fits into ASCII, has only two-byte characters or needs four-byte characters.</p>
<p>The actual details would be rather differen in PyPy, but we would like to have
the same optimization implemented.</p>
</div>
<div class="section" id="translation-toolchain">
<h2>Translation Toolchain<a class="headerlink" href="#translation-toolchain" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>Incremental or distributed translation.</li>
<li>Allow separate compilation of extension modules.</li>
</ul>
</div>
<div class="section" id="various-gcs">
<h2>Various GCs<a class="headerlink" href="#various-gcs" title="Permalink to this headline">¶</a></h2>
<p>PyPy has pluggable garbage collection policy. This means that various garbage
collectors can be written for specialized purposes, or even various
experiments can be done for the general purpose. Examples:</p>
<ul class="simple">
<li>An incremental garbage collector that has specified maximal pause times,
crucial for games</li>
<li>A garbage collector that compact memory better for mobile devices</li>
<li>A concurrent garbage collector (a lot of work)</li>
<li>A collector that keeps object flags in separate memory pages, to avoid
un-sharing all pages between several fork()ed processes</li>
</ul>
</div>
<div class="section" id="stm-software-transactional-memory">
<h2>STM (Software Transactional Memory)<a class="headerlink" href="#stm-software-transactional-memory" title="Permalink to this headline">¶</a></h2>
<p>This is work in progress.  Besides the main development path, whose goal is
to make a (relatively fast) version of pypy which includes STM, there are
independent topics that can already be experimented with on the existing,
JIT-less pypy-stm version:</p>
<ul class="simple">
<li>What kind of conflicts do we get in real use cases?  And, sometimes,
which data structures would be more appropriate?  For example, a dict
implemented as a hash table will suffer &#8220;stm collisions&#8221; in all threads
whenever one thread writes anything to it; but there could be other
implementations.  Maybe alternate strategies can be implemented at the
level of the Python interpreter (see list/dict strategies,
<tt class="docutils literal"><span class="pre">pypy/objspace/std/{list,dict}object.py</span></tt>).</li>
<li>More generally, there is the idea that we would need some kind of
&#8220;debugger&#8221;-like tool to &#8220;debug&#8221; things that are not bugs, but stm
conflicts.  How would this tool look like to the end Python
programmers?  Like a profiler?  Or like a debugger with breakpoints
on aborted transactions?  It would probably be all app-level, with
a few hooks e.g. for transaction conflicts.</li>
<li>Find good ways to have libraries using internally threads and atomics,
but not exposing threads to the user.  Right now there is a rough draft
in <tt class="docutils literal"><span class="pre">lib_pypy/transaction.py</span></tt>, but much better is possible.  For example
we could probably have an iterator-like concept that allows each loop
iteration to run in parallel.</li>
</ul>
</div>
<div class="section" id="introduce-new-benchmarks">
<h2>Introduce new benchmarks<a class="headerlink" href="#introduce-new-benchmarks" title="Permalink to this headline">¶</a></h2>
<p>We&#8217;re usually happy to introduce new benchmarks. Please consult us
before, but in general something that&#8217;s real-world python code
and is not already represented is welcome. We need at least a standalone
script that can run without parameters. Example ideas (benchmarks need
to be got from them!):</p>
<ul class="simple">
<li><cite>hg</cite></li>
</ul>
</div>
<div class="section" id="experiment-again-with-llvm-backend-for-rpython-compilation">
<h2>Experiment (again) with LLVM backend for RPython compilation<a class="headerlink" href="#experiment-again-with-llvm-backend-for-rpython-compilation" title="Permalink to this headline">¶</a></h2>
<p>We already tried working with LLVM and at the time, LLVM was not mature enough
for our needs. It&#8217;s possible that this has changed, reviving the LLVM backend
(or writing new from scratch) for static compilation would be a good project.</p>
<p>(On the other hand, just generating C code and using clang might be enough.
The issue with that is the so-called &#8220;asmgcc GC root finder&#8221;, which has tons
of issues of this own.  In my opinion (arigo), it would be definitely a
better project to try to optimize the alternative, the &#8220;shadowstack&#8221; GC root
finder, which is nicely portable.  So far it gives a pypy that is around
7% slower.)</p>
</div>
<div class="section" id="embedding-pypy">
<h2>Embedding PyPy<a class="headerlink" href="#embedding-pypy" title="Permalink to this headline">¶</a></h2>
<p>Being able to embed PyPy, say with its own limited C API, would be
useful.  But here is the most interesting variant, straight from
EuroPython live discussion :-)  We can have a generic &#8220;libpypy.so&#8221; that
can be used as a placeholder dynamic library, and when it gets loaded,
it runs a .py module that installs (via ctypes) the interface it wants
exported.  This would give us a one-size-fits-all generic .so file to be
imported by any application that wants to load .so files :-)</p>
</div>
<div class="section" id="optimising-cpyext-cpython-c-api-compatibility-layer">
<h2>Optimising cpyext (CPython C-API compatibility layer)<a class="headerlink" href="#optimising-cpyext-cpython-c-api-compatibility-layer" title="Permalink to this headline">¶</a></h2>
<p>A lot of work has gone into PyPy&#8217;s implementation of CPython&#8217;s C-API over
the last years to let it reach a practical level of compatibility, so that
C extensions for CPython work on PyPy without major rewrites. However,
there are still many edges and corner cases where it misbehaves, and it has
not received any substantial optimisation so far.</p>
<p>The objective of this project is to fix bugs in cpyext and to optimise
several performance critical parts of it, such as the reference counting
support and other heavily used C-API functions. The net result would be to
have CPython extensions run much faster on PyPy than they currently do, or
to make them work at all if they currently don&#8217;t. A part of this work would
be to get cpyext into a shape where it supports running Cython generated
extensions.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Potential project list</a><ul>
<li><a class="reference internal" href="#make-bytearray-type-fast">Make bytearray type fast</a></li>
<li><a class="reference internal" href="#implement-copy-on-write-list-slicing">Implement copy-on-write list slicing</a></li>
<li><a class="reference internal" href="#numpy-improvements">Numpy improvements</a></li>
<li><a class="reference internal" href="#improving-the-jitviewer">Improving the jitviewer</a></li>
<li><a class="reference internal" href="#optimized-unicode-representation">Optimized Unicode Representation</a></li>
<li><a class="reference internal" href="#translation-toolchain">Translation Toolchain</a></li>
<li><a class="reference internal" href="#various-gcs">Various GCs</a></li>
<li><a class="reference internal" href="#stm-software-transactional-memory">STM (Software Transactional Memory)</a></li>
<li><a class="reference internal" href="#introduce-new-benchmarks">Introduce new benchmarks</a></li>
<li><a class="reference internal" href="#experiment-again-with-llvm-backend-for-rpython-compilation">Experiment (again) with LLVM backend for RPython compilation</a></li>
<li><a class="reference internal" href="#embedding-pypy">Embedding PyPy</a></li>
<li><a class="reference internal" href="#optimising-cpyext-cpython-c-api-compatibility-layer">Optimising cpyext (CPython C-API compatibility layer)</a></li>
</ul>
</li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/project-ideas.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li><a href="index.html">PyPy 2.2.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, The PyPy Project.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>