

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Coding Guide &mdash; PyPy 2.2.0 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '2.2.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="PyPy 2.2.0 documentation" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li><a href="index.html">PyPy 2.2.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="coding-guide">
<h1><a class="toc-backref" href="#id13">Coding Guide</a><a class="headerlink" href="#coding-guide" title="Permalink to this headline">¶</a></h1>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#coding-guide" id="id13">Coding Guide</a><ul>
<li><a class="reference internal" href="#overview-and-motivation" id="id14">Overview and motivation</a><ul>
<li><a class="reference internal" href="#cpython-vs-pypy" id="id15">CPython vs. PyPy</a></li>
<li><a class="reference internal" href="#application-level-and-interpreter-level-execution-and-objects" id="id16">Application-level and interpreter-level execution and objects</a></li>
<li><a class="reference internal" href="#application-level-is-often-preferable" id="id17">Application level is often preferable</a></li>
<li><a class="reference internal" href="#our-runtime-interpreter-is-rpython" id="id18">Our runtime interpreter is &#8220;RPython&#8221;</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id1" id="id19">RPython</a><ul>
<li><a class="reference internal" href="#rpython-definition" id="id20">RPython Definition</a></li>
<li><a class="reference internal" href="#flow-restrictions" id="id21">Flow restrictions</a></li>
<li><a class="reference internal" href="#object-restrictions" id="id22">Object restrictions</a></li>
<li><a class="reference internal" href="#integer-types" id="id23">Integer Types</a></li>
<li><a class="reference internal" href="#exception-rules" id="id24">Exception rules</a></li>
<li><a class="reference internal" href="#pypy-is-debuggable-on-top-of-cpython" id="id25">PyPy is debuggable on top of CPython</a></li>
</ul>
</li>
<li><a class="reference internal" href="#wrapped" id="id26">Wrapping rules</a><ul>
<li><a class="reference internal" href="#wrapping" id="id27">Wrapping</a></li>
<li><a class="reference internal" href="#naming-conventions" id="id28">Naming conventions</a></li>
<li><a class="reference internal" href="#operations-on-w-xxx" id="id29">Operations on <tt class="docutils literal"><span class="pre">w_xxx</span></tt></a></li>
<li><a class="reference internal" href="#application-level-exceptions" id="id30">Application-level exceptions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#modules-in-pypy" id="id31">Modules in PyPy</a><ul>
<li><a class="reference internal" href="#determining-the-location-of-a-module-implementation" id="id32">Determining the location of a module implementation</a></li>
<li><a class="reference internal" href="#module-directories-import-order" id="id33">Module directories / Import order</a></li>
<li><a class="reference internal" href="#modifying-a-cpython-library-module-or-regression-test" id="id34">Modifying a CPython library module or regression test</a></li>
<li><a class="reference internal" href="#implementing-a-mixed-interpreter-application-level-module" id="id35">Implementing a mixed interpreter/application level Module</a><ul>
<li><a class="reference internal" href="#application-level-definitions" id="id36">application level definitions</a></li>
<li><a class="reference internal" href="#interpreter-level-definitions" id="id37">interpreter level definitions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#testing-modules-in-lib-pypy" id="id38">Testing modules in <tt class="docutils literal"><span class="pre">lib_pypy/</span></tt></a></li>
<li><a class="reference internal" href="#testing-modules-in-pypy-module" id="id39">Testing modules in <tt class="docutils literal"><span class="pre">pypy/module</span></tt></a></li>
<li><a class="reference internal" href="#testing-modules-in-lib-python" id="id40">Testing modules in <tt class="docutils literal"><span class="pre">lib-python</span></tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#naming-conventions-and-directory-layout" id="id41">Naming conventions and directory layout</a><ul>
<li><a class="reference internal" href="#directory-and-file-naming" id="id42">Directory and File Naming</a></li>
<li><a class="reference internal" href="#naming-of-python-objects" id="id43">Naming of python objects</a></li>
<li><a class="reference internal" href="#committing-branching-to-the-repository" id="id44">Committing &amp; Branching to the repository</a></li>
</ul>
</li>
<li><a class="reference internal" href="#using-the-development-bug-feature-tracker" id="id45">Using the development bug/feature tracker</a><ul>
<li><a class="reference internal" href="#use-your-codespeak-login-or-register" id="id46">use your codespeak login or register</a></li>
</ul>
</li>
<li><a class="reference internal" href="#test-design" id="id47">Testing in PyPy</a><ul>
<li><a class="reference internal" href="#interpreter-level-tests" id="id48">Interpreter level tests</a></li>
<li><a class="reference internal" href="#application-level-tests" id="id49">Application Level tests</a></li>
<li><a class="reference internal" href="#command-line-tool-test-all" id="id50">Command line tool test_all</a></li>
<li><a class="reference internal" href="#coverage-reports" id="id51">Coverage reports</a></li>
<li><a class="reference internal" href="#test-conventions" id="id52">Test conventions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#changing-documentation-and-website" id="id53">Changing documentation and website</a><ul>
<li><a class="reference internal" href="#documentation-website-files-in-your-local-checkout" id="id54">documentation/website files in your local checkout</a></li>
<li><a class="reference internal" href="#automatically-test-documentation-website-changes" id="id55">Automatically test documentation/website changes</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<p>This document describes coding requirements and conventions for
working with the PyPy code base.  Please read it carefully and
ask back any questions you might have. The document does not talk
very much about coding style issues. We mostly follow <a class="reference external" href="http://www.python.org/dev/peps/pep-0008/">PEP 8</a> though.
If in doubt, follow the style that is already present in the code base.</p>
<div class="section" id="overview-and-motivation">
<span id="rpython"></span><h2><a class="toc-backref" href="#id14">Overview and motivation</a><a class="headerlink" href="#overview-and-motivation" title="Permalink to this headline">¶</a></h2>
<p>We are writing a Python interpreter in Python, using Python&#8217;s well known
ability to step behind the algorithmic problems as a language. At first glance,
one might think this achieves nothing but a better understanding how the
interpreter works.  This alone would make it worth doing, but we have much
larger goals.</p>
<div class="section" id="cpython-vs-pypy">
<h3><a class="toc-backref" href="#id15">CPython vs. PyPy</a><a class="headerlink" href="#cpython-vs-pypy" title="Permalink to this headline">¶</a></h3>
<p>Compared to the CPython implementation, Python takes the role of the C
Code. We rewrite the CPython interpreter in Python itself.  We could
also aim at writing a more flexible interpreter at C level but we
want to use Python to give an alternative description of the interpreter.</p>
<p>The clear advantage is that such a description is shorter and simpler to
read, and many implementation details vanish. The drawback of this approach is
that this interpreter will be unbearably slow as long as it is run on top
of CPython.</p>
<p>To get to a useful interpreter again, we need to translate our
high-level description of Python to a lower level one.  One rather
straight-forward way is to do a whole program analysis of the PyPy
interpreter and create a C source, again. There are many other ways,
but let&#8217;s stick with this somewhat canonical approach.</p>
</div>
<div class="section" id="application-level-and-interpreter-level-execution-and-objects">
<span id="interpreter-level"></span><span id="application-level"></span><h3><a class="toc-backref" href="#id16">Application-level and interpreter-level execution and objects</a><a class="headerlink" href="#application-level-and-interpreter-level-execution-and-objects" title="Permalink to this headline">¶</a></h3>
<p>Since Python is used for implementing all of our code base, there is a
crucial distinction to be aware of: that between <em>interpreter-level</em> objects and
<em>application-level</em> objects.  The latter are the ones that you deal with
when you write normal python programs.  Interpreter-level code, however,
cannot invoke operations nor access attributes from application-level
objects.  You will immediately recognize any interpreter level code in
PyPy, because half the variable and object names start with a <tt class="docutils literal"><span class="pre">w_</span></tt>, which
indicates that they are <a class="reference internal" href="#wrapped">wrapped</a> application-level values.</p>
<p>Let&#8217;s show the difference with a simple example.  To sum the contents of
two variables <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">b</span></tt>, one would write the simple application-level
<tt class="docutils literal"><span class="pre">a+b</span></tt> &#8211; in contrast, the equivalent interpreter-level code is
<tt class="docutils literal"><span class="pre">space.add(w_a,</span> <span class="pre">w_b)</span></tt>, where <tt class="docutils literal"><span class="pre">space</span></tt> is an instance of an object space,
and <tt class="docutils literal"><span class="pre">w_a</span></tt> and <tt class="docutils literal"><span class="pre">w_b</span></tt> are typical names for the wrapped versions of the
two variables.</p>
<p>It helps to remember how CPython deals with the same issue: interpreter
level code, in CPython, is written in C and thus typical code for the
addition is <tt class="docutils literal"><span class="pre">PyNumber_Add(p_a,</span> <span class="pre">p_b)</span></tt> where <tt class="docutils literal"><span class="pre">p_a</span></tt> and <tt class="docutils literal"><span class="pre">p_b</span></tt> are C
variables of type <tt class="docutils literal"><span class="pre">PyObject*</span></tt>. This is conceptually similar to how we write
our interpreter-level code in Python.</p>
<p>Moreover, in PyPy we have to make a sharp distinction between
interpreter- and application-level <em>exceptions</em>: application exceptions
are always contained inside an instance of <tt class="docutils literal"><span class="pre">OperationError</span></tt>.  This
makes it easy to distinguish failures (or bugs) in our interpreter-level code
from failures appearing in a python application level program that we are
interpreting.</p>
</div>
<div class="section" id="application-level-is-often-preferable">
<span id="app-preferable"></span><h3><a class="toc-backref" href="#id17">Application level is often preferable</a><a class="headerlink" href="#application-level-is-often-preferable" title="Permalink to this headline">¶</a></h3>
<p>Application-level code is substantially higher-level, and therefore
correspondingly easier to write and debug.  For example, suppose we want
to implement the <tt class="docutils literal"><span class="pre">update</span></tt> method of dict objects.  Programming at
application level, we can write an obvious, simple implementation, one
that looks like an <strong>executable definition</strong> of <tt class="docutils literal"><span class="pre">update</span></tt>, for
example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">other</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
</pre></div>
</div>
<p>If we had to code only at interpreter level, we would have to code
something much lower-level and involved, say something like:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">w_self</span><span class="p">,</span> <span class="n">w_other</span><span class="p">):</span>
    <span class="n">w_keys</span> <span class="o">=</span> <span class="n">space</span><span class="o">.</span><span class="n">call_method</span><span class="p">(</span><span class="n">w_other</span><span class="p">,</span> <span class="s">&#39;keys&#39;</span><span class="p">)</span>
    <span class="n">w_iter</span> <span class="o">=</span> <span class="n">space</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="n">w_keys</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">w_key</span> <span class="o">=</span> <span class="n">space</span><span class="o">.</span><span class="n">next</span><span class="p">(</span><span class="n">w_iter</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">OperationError</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">e</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">space</span><span class="o">.</span><span class="n">w_StopIteration</span><span class="p">):</span>
                <span class="k">raise</span>       <span class="c"># re-raise other app-level exceptions</span>
            <span class="k">break</span>
        <span class="n">w_value</span> <span class="o">=</span> <span class="n">space</span><span class="o">.</span><span class="n">getitem</span><span class="p">(</span><span class="n">w_other</span><span class="p">,</span> <span class="n">w_key</span><span class="p">)</span>
        <span class="n">space</span><span class="o">.</span><span class="n">setitem</span><span class="p">(</span><span class="n">w_self</span><span class="p">,</span> <span class="n">w_key</span><span class="p">,</span> <span class="n">w_value</span><span class="p">)</span>
</pre></div>
</div>
<p>This interpreter-level implementation looks much more similar to the C
source code.  It is still more readable than its C counterpart because
it doesn&#8217;t contain memory management details and can use Python&#8217;s native
exception mechanism.</p>
<p>In any case, it should be obvious that the application-level implementation
is definitely more readable, more elegant and more maintainable than the
interpreter-level one (and indeed, dict.update is really implemented at
applevel in PyPy).</p>
<p>In fact, in almost all parts of PyPy, you find application level code in
the middle of interpreter-level code.  Apart from some bootstrapping
problems (application level functions need a certain initialization
level of the object space before they can be executed), application
level code is usually preferable.  We have an abstraction (called the
&#8216;Gateway&#8217;) which allows the caller of a function to remain ignorant of
whether a particular function is implemented at application or
interpreter level.</p>
</div>
<div class="section" id="our-runtime-interpreter-is-rpython">
<h3><a class="toc-backref" href="#id18">Our runtime interpreter is &#8220;RPython&#8221;</a><a class="headerlink" href="#our-runtime-interpreter-is-rpython" title="Permalink to this headline">¶</a></h3>
<p>In order to make a C code generator feasible all code on interpreter level has
to restrict itself to a subset of the Python language, and we adhere to some
rules which make translation to lower level languages feasible. Code on
application level can still use the full expressivity of Python.</p>
<p>Unlike source-to-source translations (like e.g. <a class="reference external" href="http://people.csail.mit.edu/jrb/Projects/starkiller.pdf">Starkiller</a> or more recently
<a class="reference external" href="http://shed-skin.blogspot.com/">ShedSkin</a>) we start
translation from live python code objects which constitute our Python
interpreter.   When doing its work of interpreting bytecode our Python
implementation must behave in a static way often referenced as
&#8220;RPythonic&#8221;.</p>
<p>However, when the PyPy interpreter is started as a Python program, it
can use all of the Python language until it reaches a certain point in
time, from which on everything that is being executed must be static.
That is, during initialization our program is free to use the
full dynamism of Python, including dynamic code generation.</p>
<p>An example can be found in the current implementation which is quite
elegant: For the definition of all the opcodes of the Python
interpreter, the module <tt class="docutils literal"><span class="pre">dis</span></tt> is imported and used to initialize our
bytecode interpreter.  (See <tt class="docutils literal"><span class="pre">__initclass__</span></tt> in
<a class="reference external" href="https://bitbucket.org/pypy/pypy/src/default/pypy/interpreter/pyopcode.py">pypy/interpreter/pyopcode.py</a>).  This
saves us from adding extra modules to PyPy. The import code is run at
startup time, and we are allowed to use the CPython builtin import
function.</p>
<p>After the startup code is finished, all resulting objects, functions,
code blocks etc. must adhere to certain runtime restrictions which we
describe further below.  Here is some background for why this is so:
during translation, a whole program analysis (&#8220;type inference&#8221;) is
performed, which makes use of the restrictions defined in RPython. This
enables the code generator to emit efficient machine level replacements
for pure integer objects, for instance.</p>
</div>
</div>
<div class="section" id="id1">
<h2><a class="toc-backref" href="#id19">RPython</a><a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<div class="section" id="rpython-definition">
<h3><a class="toc-backref" href="#id20">RPython Definition</a><a class="headerlink" href="#rpython-definition" title="Permalink to this headline">¶</a></h3>
<p>RPython is a restricted subset of Python that is amenable to static analysis.
Although there are additions to the language and some things might surprisingly
work, this is a rough list of restrictions that should be considered. Note
that there are tons of special cased restrictions that you&#8217;ll encounter
as you go. The exact definition is &#8220;RPython is everything that our translation
toolchain can accept&#8221; :)</p>
</div>
<div class="section" id="flow-restrictions">
<h3><a class="toc-backref" href="#id21">Flow restrictions</a><a class="headerlink" href="#flow-restrictions" title="Permalink to this headline">¶</a></h3>
<p><strong>variables</strong></p>
<blockquote>
<div>variables should contain values of at most one type as described in
<a class="reference internal" href="#object-restrictions">Object restrictions</a> at each control flow point, that means for
example that joining control paths using the same variable to
contain both a string and a int must be avoided.  It is allowed to
mix None (basically with the role of a null pointer) with many other
types: <cite>wrapped objects</cite>, class instances, lists, dicts, strings, etc.
but <em>not</em> with int, floats or tuples.</div></blockquote>
<p><strong>constants</strong></p>
<blockquote>
<div>all module globals are considered constants.  Their binding must not
be changed at run-time.  Moreover, global (i.e. prebuilt) lists and
dictionaries are supposed to be immutable: modifying e.g. a global
list will give inconsistent results.  However, global instances don&#8217;t
have this restriction, so if you need mutable global state, store it
in the attributes of some prebuilt singleton instance.</div></blockquote>
<p><strong>control structures</strong></p>
<blockquote>
<div>all allowed, <tt class="docutils literal"><span class="pre">for</span></tt> loops restricted to builtin types, generators
very restricted.</div></blockquote>
<p><strong>range</strong></p>
<blockquote>
<div><tt class="docutils literal"><span class="pre">range</span></tt> and <tt class="docutils literal"><span class="pre">xrange</span></tt> are identical. <tt class="docutils literal"><span class="pre">range</span></tt> does not necessarily create an array,
only if the result is modified. It is allowed everywhere and completely
implemented. The only visible difference to CPython is the inaccessibility
of the <tt class="docutils literal"><span class="pre">xrange</span></tt> fields start, stop and step.</div></blockquote>
<p><strong>definitions</strong></p>
<blockquote>
<div>run-time definition of classes or functions is not allowed.</div></blockquote>
<p><strong>generators</strong></p>
<blockquote>
<div>generators are supported, but their exact scope is very limited. you can&#8217;t
merge two different generator in one control point.</div></blockquote>
<p><strong>exceptions</strong></p>
<ul class="simple">
<li>fully supported</li>
<li>see below <a class="reference internal" href="#exception-rules">Exception rules</a> for restrictions on exceptions raised by built-in operations</li>
</ul>
</div>
<div class="section" id="object-restrictions">
<h3><a class="toc-backref" href="#id22">Object restrictions</a><a class="headerlink" href="#object-restrictions" title="Permalink to this headline">¶</a></h3>
<p>We are using</p>
<p><strong>integer, float, boolean</strong></p>
<blockquote>
<div>works.</div></blockquote>
<p><strong>strings</strong></p>
<blockquote>
<div>a lot of, but not all string methods are supported and those that are
supported, not necesarilly accept all arguments.  Indexes can be
negative.  In case they are not, then you get slightly more efficient
code if the translator can prove that they are non-negative.  When
slicing a string it is necessary to prove that the slice start and
stop indexes are non-negative. There is no implicit str-to-unicode cast
anywhere. Simple string formatting using the <tt class="docutils literal"><span class="pre">%</span></tt> operator works, as long
as the format string is known at translation time; the only supported
formatting specifiers are <tt class="docutils literal"><span class="pre">%s</span></tt>, <tt class="docutils literal"><span class="pre">%d</span></tt>, <tt class="docutils literal"><span class="pre">%x</span></tt>, <tt class="docutils literal"><span class="pre">%o</span></tt>, <tt class="docutils literal"><span class="pre">%f</span></tt>, plus
<tt class="docutils literal"><span class="pre">%r</span></tt> but only for user-defined instances. Modifiers such as conversion
flags, precision, length etc. are not supported. Moreover, it is forbidden
to mix unicode and strings when formatting.</div></blockquote>
<p><strong>tuples</strong></p>
<blockquote>
<div>no variable-length tuples; use them to store or return pairs or n-tuples of
values. Each combination of types for elements and length constitute
a separate and not mixable type.</div></blockquote>
<p><strong>lists</strong></p>
<blockquote>
<div><p>lists are used as an allocated array.  Lists are over-allocated, so list.append()
is reasonably fast. However, if you use a fixed-size list, the code
is more efficient. Annotator can figure out most of the time that your
list is fixed-size, even when you use list comprehension.
Negative or out-of-bound indexes are only allowed for the
most common operations, as follows:</p>
<ul class="simple">
<li><em>indexing</em>:
positive and negative indexes are allowed. Indexes are checked when requested
by an IndexError exception clause.</li>
<li><em>slicing</em>:
the slice start must be within bounds. The stop doesn&#8217;t need to, but it must
not be smaller than the start.  All negative indexes are disallowed, except for
the [:-1] special case.  No step.  Slice deletion follows the same rules.</li>
<li><em>slice assignment</em>:
only supports <tt class="docutils literal"><span class="pre">lst[x:y]</span> <span class="pre">=</span> <span class="pre">sublist</span></tt>, if <tt class="docutils literal"><span class="pre">len(sublist)</span> <span class="pre">==</span> <span class="pre">y</span> <span class="pre">-</span> <span class="pre">x</span></tt>.
In other words, slice assignment cannot change the total length of the list,
but just replace items.</li>
<li><em>other operators</em>:
<tt class="docutils literal"><span class="pre">+</span></tt>, <tt class="docutils literal"><span class="pre">+=</span></tt>, <tt class="docutils literal"><span class="pre">in</span></tt>, <tt class="docutils literal"><span class="pre">*</span></tt>, <tt class="docutils literal"><span class="pre">*=</span></tt>, <tt class="docutils literal"><span class="pre">==</span></tt>, <tt class="docutils literal"><span class="pre">!=</span></tt> work as expected.</li>
<li><em>methods</em>:
append, index, insert, extend, reverse, pop.  The index used in pop() follows
the same rules as for <em>indexing</em> above.  The index used in insert() must be within
bounds and not negative.</li>
</ul>
</div></blockquote>
<p><strong>dicts</strong></p>
<blockquote>
<div>dicts with a unique key type only, provided it is hashable. Custom
hash functions and custom equality will not be honored.
Use <tt class="docutils literal"><span class="pre">rpython.rlib.objectmodel.r_dict</span></tt> for custom hash functions.</div></blockquote>
<p><strong>list comprehensions</strong></p>
<blockquote>
<div>May be used to create allocated, initialized arrays.</div></blockquote>
<p><strong>functions</strong></p>
<ul class="simple">
<li>statically called functions may use defaults and a variable number of
arguments (which may be passed as a list instead of a tuple, so write code
that does not depend on it being a tuple).</li>
<li>dynamic dispatch enforces the use of signatures that are equal for all
possible called function, or at least &#8220;compatible enough&#8221;.  This
concerns mainly method calls, when the method is overridden or in any
way given different definitions in different classes.  It also concerns
the less common case of explicitly manipulated function objects.
Describing the exact compatibility rules is rather involved (but if you
break them, you should get explicit errors from the rtyper and not
obscure crashes.)</li>
</ul>
<p><strong>builtin functions</strong></p>
<blockquote>
<div><p>A number of builtin functions can be used.  The precise set can be
found in <a class="reference external" href="https://bitbucket.org/pypy/pypy/src/default/rpython/annotator/builtin.py">rpython/annotator/builtin.py</a> (see <tt class="docutils literal"><span class="pre">def</span> <span class="pre">builtin_xxx()</span></tt>).
Some builtin functions may be limited in what they support, though.</p>
<p><tt class="docutils literal"><span class="pre">int,</span> <span class="pre">float,</span> <span class="pre">str,</span> <span class="pre">ord,</span> <span class="pre">chr</span></tt>... are available as simple conversion
functions.  Note that <tt class="docutils literal"><span class="pre">int,</span> <span class="pre">float,</span> <span class="pre">str</span></tt>... have a special meaning as
a type inside of isinstance only.</p>
</div></blockquote>
<p><strong>classes</strong></p>
<ul class="simple">
<li>methods and other class attributes do not change after startup</li>
<li>single inheritance is fully supported</li>
<li>use <cite>rpython.rlib.objectmodel.import_from_mixin(M)</cite> in a class
body to copy the whole content of a class <cite>M</cite>.  This can be used
to implement mixins: functions and staticmethods are duplicated
(the other class attributes are just copied unmodified).</li>
<li>classes are first-class objects too</li>
</ul>
<p><strong>objects</strong></p>
<blockquote>
<div>Normal rules apply. Special methods are not honoured, except <tt class="docutils literal"><span class="pre">__init__</span></tt>,
<tt class="docutils literal"><span class="pre">__del__</span></tt> and <tt class="docutils literal"><span class="pre">__iter__</span></tt>.</div></blockquote>
<p>This layout makes the number of types to take care about quite limited.</p>
</div>
<div class="section" id="integer-types">
<h3><a class="toc-backref" href="#id23">Integer Types</a><a class="headerlink" href="#integer-types" title="Permalink to this headline">¶</a></h3>
<p>While implementing the integer type, we stumbled over the problem that
integers are quite in flux in CPython right now. Starting with Python 2.4,
integers mutate into longs on overflow.  In contrast, we need
a way to perform wrap-around machine-sized arithmetic by default, while still
being able to check for overflow when we need it explicitly.  Moreover, we need
a consistent behavior before and after translation.</p>
<p>We use normal integers for signed arithmetic.  It means that before
translation we get longs in case of overflow, and after translation we get a
silent wrap-around.  Whenever we need more control, we use the following
helpers (which live in <a class="reference external" href="https://bitbucket.org/pypy/pypy/src/default/rpython/rlib/rarithmetic.py">rpython/rlib/rarithmetic.py</a>):</p>
<p><strong>ovfcheck()</strong></p>
<blockquote>
<div><p>This special function should only be used with a single arithmetic operation
as its argument, e.g. <tt class="docutils literal"><span class="pre">z</span> <span class="pre">=</span> <span class="pre">ovfcheck(x+y)</span></tt>.  Its intended meaning is to
perform the given operation in overflow-checking mode.</p>
<p>At run-time, in Python, the ovfcheck() function itself checks the result
and raises OverflowError if it is a <tt class="docutils literal"><span class="pre">long</span></tt>.  But the code generators use
ovfcheck() as a hint: they replace the whole <tt class="docutils literal"><span class="pre">ovfcheck(x+y)</span></tt> expression
with a single overflow-checking addition in C.</p>
</div></blockquote>
<p><strong>intmask()</strong></p>
<blockquote>
<div>This function is used for wrap-around arithmetic.  It returns the lower bits
of its argument, masking away anything that doesn&#8217;t fit in a C &#8220;signed long int&#8221;.
Its purpose is, in Python, to convert from a Python <tt class="docutils literal"><span class="pre">long</span></tt> that resulted from a
previous operation back to a Python <tt class="docutils literal"><span class="pre">int</span></tt>.  The code generators ignore
intmask() entirely, as they are doing wrap-around signed arithmetic all the time
by default anyway.  (We have no equivalent of the &#8220;int&#8221; versus &#8220;long int&#8221;
distinction of C at the moment and assume &#8220;long ints&#8221; everywhere.)</div></blockquote>
<p><strong>r_uint</strong></p>
<blockquote>
<div>In a few cases (e.g. hash table manipulation), we need machine-sized unsigned
arithmetic.  For these cases there is the r_uint class, which is a pure
Python implementation of word-sized unsigned integers that silently wrap
around.  (&#8220;word-sized&#8221; and &#8220;machine-sized&#8221; are used equivalently and mean
the native size, which you get using &#8220;unsigned long&#8221; in C.)
The purpose of this class (as opposed to helper functions as above)
is consistent typing: both Python and the annotator will propagate r_uint
instances in the program and interpret all the operations between them as
unsigned.  Instances of r_uint are special-cased by the code generators to
use the appropriate low-level type and operations.
Mixing of (signed) integers and r_uint in operations produces r_uint that
means unsigned results.  To convert back from r_uint to signed integers, use
intmask().</div></blockquote>
</div>
<div class="section" id="exception-rules">
<h3><a class="toc-backref" href="#id24">Exception rules</a><a class="headerlink" href="#exception-rules" title="Permalink to this headline">¶</a></h3>
<p>Exceptions are by default not generated for simple cases.:</p>
<div class="highlight-python"><pre>#!/usr/bin/python

    lst = [1,2,3,4,5]
    item = lst[i]    # this code is not checked for out-of-bound access

    try:
        item = lst[i]
    except IndexError:
        # complain</pre>
</div>
<p>Code with no exception handlers does not raise exceptions (after it has been
translated, that is.  When you run it on top of CPython, it may raise
exceptions, of course). By supplying an exception handler, you ask for error
checking. Without, you assure the system that the operation cannot fail.
This rule does not apply to <em>function calls</em>: any called function is
assumed to be allowed to raise any exception.</p>
<p>For example:</p>
<div class="highlight-python"><pre>x = 5.1
x = x + 1.2       # not checked for float overflow
try:
    x = x + 1.2
except OverflowError:
    # float result too big</pre>
</div>
<p>But:</p>
<div class="highlight-python"><pre>z = some_function(x, y)    # can raise any exception
try:
    z = some_other_function(x, y)
except IndexError:
    # only catches explicitly-raised IndexErrors in some_other_function()
    # other exceptions can be raised, too, and will not be caught here.</pre>
</div>
<p>The ovfcheck() function described above follows the same rule: in case of
overflow, it explicitly raise OverflowError, which can be caught anywhere.</p>
<p>Exceptions explicitly raised or re-raised will always be generated.</p>
</div>
<div class="section" id="pypy-is-debuggable-on-top-of-cpython">
<h3><a class="toc-backref" href="#id25">PyPy is debuggable on top of CPython</a><a class="headerlink" href="#pypy-is-debuggable-on-top-of-cpython" title="Permalink to this headline">¶</a></h3>
<p>PyPy has the advantage that it is runnable on standard
CPython.  That means, we can run all of PyPy with all exception
handling enabled, so we might catch cases where we failed to
adhere to our implicit assertions.</p>
</div>
</div>
<div class="section" id="wrapped">
<span id="wrapping-rules"></span><span id="id2"></span><h2><a class="toc-backref" href="#id26">Wrapping rules</a><a class="headerlink" href="#wrapped" title="Permalink to this headline">¶</a></h2>
<div class="section" id="wrapping">
<h3><a class="toc-backref" href="#id27">Wrapping</a><a class="headerlink" href="#wrapping" title="Permalink to this headline">¶</a></h3>
<p>PyPy is made of Python source code at two levels: there is on the one hand
<em>application-level code</em> that looks like normal Python code, and that
implements some functionalities as one would expect from Python code (e.g. one
can give a pure Python implementation of some built-in functions like
<tt class="docutils literal"><span class="pre">zip()</span></tt>).  There is also <em>interpreter-level code</em> for the functionalities
that must more directly manipulate interpreter data and objects (e.g. the main
loop of the interpreter, and the various object spaces).</p>
<p>Application-level code doesn&#8217;t see object spaces explicitly: it runs using an
object space to support the objects it manipulates, but this is implicit.
There is no need for particular conventions for application-level code.  The
sequel is only about interpreter-level code.  (Ideally, no application-level
variable should be called <tt class="docutils literal"><span class="pre">space</span></tt> or <tt class="docutils literal"><span class="pre">w_xxx</span></tt> to avoid confusion.)</p>
<p>The <tt class="docutils literal"><span class="pre">w_</span></tt> prefixes so lavishly used in the example above indicate,
by PyPy coding convention, that we are dealing with <em>wrapped</em> (or <em>boxed</em>) objects,
that is, interpreter-level objects which the object space constructs
to implement corresponding application-level objects.  Each object
space supplies <tt class="docutils literal"><span class="pre">wrap</span></tt>, <tt class="docutils literal"><span class="pre">unwrap</span></tt>, <tt class="docutils literal"><span class="pre">int_w</span></tt>, <tt class="docutils literal"><span class="pre">interpclass_w</span></tt>,
etc. operations that move between the two levels for objects of simple
built-in types; each object space also implements other Python types
with suitable interpreter-level classes with some amount of internal
structure.</p>
<p>For example, an application-level Python <tt class="docutils literal"><span class="pre">list</span></tt>
is implemented by the <a class="reference external" href="objspace.html#standard-object-space">standard object space</a> as an
instance of <tt class="docutils literal"><span class="pre">W_ListObject</span></tt>, which has an instance attribute
<tt class="docutils literal"><span class="pre">wrappeditems</span></tt> (an interpreter-level list which contains the
application-level list&#8217;s items as wrapped objects).</p>
<p>The rules are described in more details below.</p>
</div>
<div class="section" id="naming-conventions">
<h3><a class="toc-backref" href="#id28">Naming conventions</a><a class="headerlink" href="#naming-conventions" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">space</span></tt>: the object space is only visible at
interpreter-level code, where it is by convention passed around by the name
<tt class="docutils literal"><span class="pre">space</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">w_xxx</span></tt>: any object seen by application-level code is an
object explicitly managed by the object space.  From the
interpreter-level point of view, this is called a <em>wrapped</em>
object.  The <tt class="docutils literal"><span class="pre">w_</span></tt> prefix is used for any type of
application-level object.</li>
<li><tt class="docutils literal"><span class="pre">xxx_w</span></tt>: an interpreter-level container for wrapped
objects, for example a list or a dict containing wrapped
objects.  Not to be confused with a wrapped object that
would be a list or a dict: these are normal wrapped objects,
so they use the <tt class="docutils literal"><span class="pre">w_</span></tt> prefix.</li>
</ul>
</div>
<div class="section" id="operations-on-w-xxx">
<h3><a class="toc-backref" href="#id29">Operations on <tt class="docutils literal"><span class="pre">w_xxx</span></tt></a><a class="headerlink" href="#operations-on-w-xxx" title="Permalink to this headline">¶</a></h3>
<p>The core bytecode interpreter considers wrapped objects as black boxes.
It is not allowed to inspect them directly.  The allowed
operations are all implemented on the object space: they are
called <tt class="docutils literal"><span class="pre">space.xxx()</span></tt>, where <tt class="docutils literal"><span class="pre">xxx</span></tt> is a standard operation
name (<tt class="docutils literal"><span class="pre">add</span></tt>, <tt class="docutils literal"><span class="pre">getattr</span></tt>, <tt class="docutils literal"><span class="pre">call</span></tt>, <tt class="docutils literal"><span class="pre">eq</span></tt>...). They are documented in the
<a class="reference external" href="objspace.html#interface">object space document</a>.</p>
<p>A short warning: <strong>don&#8217;t do</strong> <tt class="docutils literal"><span class="pre">w_x</span> <span class="pre">==</span> <span class="pre">w_y</span></tt> or <tt class="docutils literal"><span class="pre">w_x</span> <span class="pre">is</span> <span class="pre">w_y</span></tt>!
rationale for this rule is that there is no reason that two
wrappers are related in any way even if they contain what
looks like the same object at application-level.  To check
for equality, use <tt class="docutils literal"><span class="pre">space.is_true(space.eq(w_x,</span> <span class="pre">w_y))</span></tt> or
even better the short-cut <tt class="docutils literal"><span class="pre">space.eq_w(w_x,</span> <span class="pre">w_y)</span></tt> returning
directly a interpreter-level bool.  To check for identity,
use <tt class="docutils literal"><span class="pre">space.is_true(space.is_(w_x,</span> <span class="pre">w_y))</span></tt> or better
<tt class="docutils literal"><span class="pre">space.is_w(w_x,</span> <span class="pre">w_y)</span></tt>.</p>
</div>
<div class="section" id="application-level-exceptions">
<span id="applevel-exceptions"></span><h3><a class="toc-backref" href="#id30">Application-level exceptions</a><a class="headerlink" href="#application-level-exceptions" title="Permalink to this headline">¶</a></h3>
<p>Interpreter-level code can use exceptions freely.  However,
all application-level exceptions are represented as an
<tt class="docutils literal"><span class="pre">OperationError</span></tt> at interpreter-level.  In other words, all
exceptions that are potentially visible at application-level
are internally an <tt class="docutils literal"><span class="pre">OperationError</span></tt>.  This is the case of all
errors reported by the object space operations
(<tt class="docutils literal"><span class="pre">space.add()</span></tt> etc.).</p>
<p>To raise an application-level exception:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">raise</span> <span class="n">OperationError</span><span class="p">(</span><span class="n">space</span><span class="o">.</span><span class="n">w_XxxError</span><span class="p">,</span> <span class="n">space</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="s">&quot;message&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>To catch a specific application-level exception:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">try</span><span class="p">:</span>
    <span class="o">...</span>
<span class="k">except</span> <span class="n">OperationError</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">e</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">space</span><span class="o">.</span><span class="n">w_XxxError</span><span class="p">):</span>
        <span class="k">raise</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>This construct catches all application-level exceptions, so we
have to match it against the particular <tt class="docutils literal"><span class="pre">w_XxxError</span></tt> we are
interested in and re-raise other exceptions.  The exception
instance <tt class="docutils literal"><span class="pre">e</span></tt> holds two attributes that you can inspect:
<tt class="docutils literal"><span class="pre">e.w_type</span></tt> and <tt class="docutils literal"><span class="pre">e.w_value</span></tt>.  Do not use <tt class="docutils literal"><span class="pre">e.w_type</span></tt> to
match an exception, as this will miss exceptions that are
instances of subclasses.</p>
</div>
</div>
<div class="section" id="modules-in-pypy">
<span id="modules"></span><h2><a class="toc-backref" href="#id31">Modules in PyPy</a><a class="headerlink" href="#modules-in-pypy" title="Permalink to this headline">¶</a></h2>
<p>Modules visible from application programs are imported from
interpreter or application level files.  PyPy reuses almost all python
modules of CPython&#8217;s standard library, currently from version 2.7.3.  We
sometimes need to <a class="reference internal" href="#modify-modules">modify modules</a> and - more often - regression tests
because they rely on implementation details of CPython.</p>
<p>If we don&#8217;t just modify an original CPython module but need to rewrite
it from scratch we put it into <a class="reference external" href="https://bitbucket.org/pypy/pypy/src/default/lib_pypy/">lib_pypy/</a> as a pure application level
module.</p>
<p>When we need access to interpreter-level objects we put the module into
<a class="reference external" href="https://bitbucket.org/pypy/pypy/src/default/pypy/module/">pypy/module</a>.  Such modules use a <a class="reference internal" href="#mixed-module-mechanism">mixed module mechanism</a>
which makes it convenient to use both interpreter- and application-level parts
for the implementation.  Note that there is no extra facility for
pure-interpreter level modules, you just write a mixed module and leave the
application-level part empty.</p>
<div class="section" id="determining-the-location-of-a-module-implementation">
<h3><a class="toc-backref" href="#id32">Determining the location of a module implementation</a><a class="headerlink" href="#determining-the-location-of-a-module-implementation" title="Permalink to this headline">¶</a></h3>
<p>You can interactively find out where a module comes from, when running py.py.
here are examples for the possible locations:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="go">&gt;&gt;&gt;&gt; import sys</span>
<span class="go">&gt;&gt;&gt;&gt; sys.__file__</span>
<span class="go">&#39;/home/hpk/pypy-dist/pypy/module/sys&#39;</span>

<span class="go">&gt;&gt;&gt;&gt; import cPickle</span>
<span class="go">&gt;&gt;&gt;&gt; cPickle.__file__</span>
<span class="go">&#39;/home/hpk/pypy-dist/lib_pypy/cPickle..py&#39;</span>

<span class="go">&gt;&gt;&gt;&gt; import os</span>
<span class="go">&gt;&gt;&gt;&gt; os.__file__</span>
<span class="go">&#39;/home/hpk/pypy-dist/lib-python/2.7/os.py&#39;</span>
<span class="go">&gt;&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="module-directories-import-order">
<h3><a class="toc-backref" href="#id33">Module directories / Import order</a><a class="headerlink" href="#module-directories-import-order" title="Permalink to this headline">¶</a></h3>
<p>Here is the order in which PyPy looks up Python modules:</p>
<p><em>pypy/module</em></p>
<blockquote>
<div>mixed interpreter/app-level builtin modules, such as
the <tt class="docutils literal"><span class="pre">sys</span></tt> and <tt class="docutils literal"><span class="pre">__builtin__</span></tt> module.</div></blockquote>
<p><em>contents of PYTHONPATH</em></p>
<blockquote>
<div>lookup application level modules in each of the <tt class="docutils literal"><span class="pre">:</span></tt> separated
list of directories, specified in the <tt class="docutils literal"><span class="pre">PYTHONPATH</span></tt> environment
variable.</div></blockquote>
<p><em>lib_pypy/</em></p>
<blockquote>
<div>contains pure Python reimplementation of modules.</div></blockquote>
<p><em>lib-python/2.7/</em></p>
<blockquote>
<div>The modified CPython library.</div></blockquote>
</div>
<div class="section" id="modifying-a-cpython-library-module-or-regression-test">
<span id="modify-modules"></span><h3><a class="toc-backref" href="#id34">Modifying a CPython library module or regression test</a><a class="headerlink" href="#modifying-a-cpython-library-module-or-regression-test" title="Permalink to this headline">¶</a></h3>
<p>Although PyPy is very compatible with CPython we sometimes need
to change modules contained in our copy of the standard library,
often due to the fact that PyPy works with all new-style classes
by default and CPython has a number of places where it relies
on some classes being old-style.</p>
<p>We just maintain those changes in place,
to see what is changed we have a branch called <cite>vendor/stdlib</cite>
wich contains the unmodified cpython stdlib</p>
</div>
<div class="section" id="implementing-a-mixed-interpreter-application-level-module">
<span id="mixed-modules"></span><span id="mixed-module-mechanism"></span><h3><a class="toc-backref" href="#id35">Implementing a mixed interpreter/application level Module</a><a class="headerlink" href="#implementing-a-mixed-interpreter-application-level-module" title="Permalink to this headline">¶</a></h3>
<p>If a module needs to access PyPy&#8217;s interpreter level
then it is implemented as a mixed module.</p>
<p>Mixed modules are directories in <a class="reference external" href="https://bitbucket.org/pypy/pypy/src/default/pypy/module/">pypy/module</a> with an  <cite>__init__.py</cite>
file containing specifications where each name in a module comes from.
Only specified names will be exported to a Mixed Module&#8217;s applevel
namespace.</p>
<p>Sometimes it is necessary to really write some functions in C (or
whatever target language). See <a class="reference external" href="rffi.html">rffi</a> and <a class="reference external" href="translation.html#extfunccalls">external functions
documentation</a> for details. The latter approach is cumbersome and
being phased out and former has currently quite a few rough edges.</p>
<div class="section" id="application-level-definitions">
<h4><a class="toc-backref" href="#id36">application level definitions</a><a class="headerlink" href="#application-level-definitions" title="Permalink to this headline">¶</a></h4>
<p>Application level specifications are found in the <cite>appleveldefs</cite>
dictionary found in <tt class="docutils literal"><span class="pre">__init__.py</span></tt> files of directories in <tt class="docutils literal"><span class="pre">pypy/module</span></tt>.
For example, in <a class="reference external" href="https://bitbucket.org/pypy/pypy/src/default/pypy/module/__builtin__/__init__.py">pypy/module/__builtin__/__init__.py</a> you find the following
entry specifying where <tt class="docutils literal"><span class="pre">__builtin__.locals</span></tt> comes from:</p>
<div class="highlight-python"><pre>...
'locals'        : 'app_inspect.locals',
...</pre>
</div>
<p>The <tt class="docutils literal"><span class="pre">app_</span></tt> prefix indicates that the submodule <tt class="docutils literal"><span class="pre">app_inspect</span></tt> is
interpreted at application level and the wrapped function value for <tt class="docutils literal"><span class="pre">locals</span></tt>
will be extracted accordingly.</p>
</div>
<div class="section" id="interpreter-level-definitions">
<h4><a class="toc-backref" href="#id37">interpreter level definitions</a><a class="headerlink" href="#interpreter-level-definitions" title="Permalink to this headline">¶</a></h4>
<p>Interpreter level specifications are found in the <tt class="docutils literal"><span class="pre">interpleveldefs</span></tt>
dictionary found in <tt class="docutils literal"><span class="pre">__init__.py</span></tt> files of directories in <tt class="docutils literal"><span class="pre">pypy/module</span></tt>.
For example, in <a class="reference external" href="https://bitbucket.org/pypy/pypy/src/default/pypy/module/__builtin__/__init__.py">pypy/module/__builtin__/__init__.py</a> the following
entry specifies where <tt class="docutils literal"><span class="pre">__builtin__.len</span></tt> comes from:</p>
<div class="highlight-python"><pre>...
'len'       : 'operation.len',
...</pre>
</div>
<p>The <tt class="docutils literal"><span class="pre">operation</span></tt> submodule lives at interpreter level and <tt class="docutils literal"><span class="pre">len</span></tt>
is expected to be exposable to application level.  Here is
the definition for <tt class="docutils literal"><span class="pre">operation.len()</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">len</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">w_obj</span><span class="p">):</span>
    <span class="s">&quot;len(object) -&gt; integer</span><span class="se">\n\n</span><span class="s">Return the number of items of a sequence or mapping.&quot;</span>
    <span class="k">return</span> <span class="n">space</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">w_obj</span><span class="p">)</span>
</pre></div>
</div>
<p>Exposed interpreter level functions usually take a <tt class="docutils literal"><span class="pre">space</span></tt> argument
and some wrapped values (see <a class="reference internal" href="#wrapping-rules">wrapping rules</a>) .</p>
<p>You can also use a convenient shortcut in <tt class="docutils literal"><span class="pre">interpleveldefs</span></tt> dictionaries:
namely an expression in parentheses to specify an interpreter level
expression directly (instead of pulling it indirectly from a file):</p>
<div class="highlight-python"><pre>...
'None'          : '(space.w_None)',
'False'         : '(space.w_False)',
...</pre>
</div>
<p>The interpreter level expression has a <tt class="docutils literal"><span class="pre">space</span></tt> binding when
it is executed.</p>
<p>Adding an entry under pypy/module (e.g. mymodule) entails automatic
creation of a new config option (such as &#8211;withmod-mymodule and
&#8211;withoutmod-mymodule (the later being the default)) for py.py and
translate.py.</p>
</div>
</div>
<div class="section" id="testing-modules-in-lib-pypy">
<h3><a class="toc-backref" href="#id38">Testing modules in <tt class="docutils literal"><span class="pre">lib_pypy/</span></tt></a><a class="headerlink" href="#testing-modules-in-lib-pypy" title="Permalink to this headline">¶</a></h3>
<p>You can go to the <a class="reference external" href="https://bitbucket.org/pypy/pypy/src/default/lib_pypy/pypy_test/">lib_pypy/pypy_test/</a> directory and invoke the testing tool
(&#8220;py.test&#8221; or &#8220;python ../../pypy/test_all.py&#8221;) to run tests against the
lib_pypy hierarchy.  Note, that tests in <a class="reference external" href="https://bitbucket.org/pypy/pypy/src/default/lib_pypy/pypy_test/">lib_pypy/pypy_test/</a> are allowed
and encouraged to let their tests run at interpreter level although
<a class="reference external" href="https://bitbucket.org/pypy/pypy/src/default/lib_pypy/">lib_pypy/</a> modules eventually live at PyPy&#8217;s application level.
This allows us to quickly test our python-coded reimplementations
against CPython.</p>
</div>
<div class="section" id="testing-modules-in-pypy-module">
<h3><a class="toc-backref" href="#id39">Testing modules in <tt class="docutils literal"><span class="pre">pypy/module</span></tt></a><a class="headerlink" href="#testing-modules-in-pypy-module" title="Permalink to this headline">¶</a></h3>
<p>Simply change to <tt class="docutils literal"><span class="pre">pypy/module</span></tt> or to a subdirectory and <a class="reference internal" href="#run-the-tests-as-usual">run the
tests as usual</a>.</p>
</div>
<div class="section" id="testing-modules-in-lib-python">
<h3><a class="toc-backref" href="#id40">Testing modules in <tt class="docutils literal"><span class="pre">lib-python</span></tt></a><a class="headerlink" href="#testing-modules-in-lib-python" title="Permalink to this headline">¶</a></h3>
<p>In order to let CPython&#8217;s regression tests run against PyPy
you can switch to the <a class="reference external" href="https://bitbucket.org/pypy/pypy/src/default/lib-python/">lib-python/</a> directory and run
the testing tool in order to start compliance tests.
(XXX check windows compatibility for producing test reports).</p>
</div>
</div>
<div class="section" id="naming-conventions-and-directory-layout">
<h2><a class="toc-backref" href="#id41">Naming conventions and directory layout</a><a class="headerlink" href="#naming-conventions-and-directory-layout" title="Permalink to this headline">¶</a></h2>
<div class="section" id="directory-and-file-naming">
<h3><a class="toc-backref" href="#id42">Directory and File Naming</a><a class="headerlink" href="#directory-and-file-naming" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>directories/modules/namespaces are always <strong>lowercase</strong></li>
<li>never use plural names in directory and file names</li>
<li><tt class="docutils literal"><span class="pre">__init__.py</span></tt> is usually empty except for
<tt class="docutils literal"><span class="pre">pypy/objspace/*</span></tt> and <tt class="docutils literal"><span class="pre">pypy/module/*/__init__.py</span></tt>.</li>
<li>don&#8217;t use more than 4 directory nesting levels</li>
<li>keep filenames concise and completion-friendly.</li>
</ul>
</div>
<div class="section" id="naming-of-python-objects">
<h3><a class="toc-backref" href="#id43">Naming of python objects</a><a class="headerlink" href="#naming-of-python-objects" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>class names are <strong>CamelCase</strong></li>
<li>functions/methods are lowercase and <tt class="docutils literal"><span class="pre">_</span></tt> separated</li>
<li>objectspace classes are spelled <tt class="docutils literal"><span class="pre">XyzObjSpace</span></tt>. e.g.<ul>
<li>StdObjSpace</li>
<li>FlowObjSpace</li>
</ul>
</li>
<li>at interpreter level and in ObjSpace all boxed values
have a leading <tt class="docutils literal"><span class="pre">w_</span></tt> to indicate &#8220;wrapped values&#8221;.  This
includes w_self.  Don&#8217;t use <tt class="docutils literal"><span class="pre">w_</span></tt> in application level
python only code.</li>
</ul>
</div>
<div class="section" id="committing-branching-to-the-repository">
<h3><a class="toc-backref" href="#id44">Committing &amp; Branching to the repository</a><a class="headerlink" href="#committing-branching-to-the-repository" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">write good log messages because several people
are reading the diffs.</p>
</li>
<li><p class="first">What was previously called <tt class="docutils literal"><span class="pre">trunk</span></tt> is called the <tt class="docutils literal"><span class="pre">default</span></tt> branch in
mercurial. Branches in mercurial are always pushed together with the rest
of the repository. To create a <tt class="docutils literal"><span class="pre">try1</span></tt> branch (assuming that a branch named
<tt class="docutils literal"><span class="pre">try1</span></tt> doesn&#8217;t already exists) you should do:</p>
<div class="highlight-python"><pre>hg branch try1</pre>
</div>
<p>The branch will be recorded in the repository only after a commit. To switch
back to the default branch:</p>
<div class="highlight-python"><pre>hg update default</pre>
</div>
<p>For further details use the help or refer to the <a class="reference external" href="http://mercurial.selenic.com/wiki/Branch">official wiki</a>:</p>
<div class="highlight-python"><pre>hg help branch</pre>
</div>
</li>
</ul>
</div>
</div>
<div class="section" id="using-the-development-bug-feature-tracker">
<span id="using-development-tracker"></span><h2><a class="toc-backref" href="#id45">Using the development bug/feature tracker</a><a class="headerlink" href="#using-the-development-bug-feature-tracker" title="Permalink to this headline">¶</a></h2>
<p>We have a <a class="reference external" href="https://bugs.pypy.org/">development tracker</a>, based on Richard Jones&#8217;
<a class="reference external" href="http://roundup.sourceforge.net/">roundup</a> application.  You can file bugs,
feature requests or see what&#8217;s going on
for the next milestone, both from an E-Mail and from a
web interface.</p>
<div class="section" id="use-your-codespeak-login-or-register">
<h3><a class="toc-backref" href="#id46">use your codespeak login or register</a><a class="headerlink" href="#use-your-codespeak-login-or-register" title="Permalink to this headline">¶</a></h3>
<p>If you have an existing codespeak account, you can use it to login within the
tracker. Else, you can <a class="reference external" href="https://bugs.pypy.org/user?&#64;template=register">register with the tracker</a> easily.</p>
</div>
</div>
<div class="section" id="test-design">
<span id="testing-in-pypy"></span><span id="id3"></span><h2><a class="toc-backref" href="#id47">Testing in PyPy</a><a class="headerlink" href="#test-design" title="Permalink to this headline">¶</a></h2>
<p>Our tests are based on the <a class="reference external" href="http://pytest.org/">py.test</a> tool which lets you write
unittests without boilerplate.  All tests of modules
in a directory usually reside in a subdirectory <strong>test</strong>.  There are
basically two types of unit tests:</p>
<ul class="simple">
<li><strong>Interpreter Level tests</strong>. They run at the same level as PyPy&#8217;s
interpreter.</li>
<li><strong>Application Level tests</strong>. They run at application level which means
that they look like straight python code but they are interpreted by PyPy.</li>
</ul>
<div class="section" id="interpreter-level-tests">
<h3><a class="toc-backref" href="#id48">Interpreter level tests</a><a class="headerlink" href="#interpreter-level-tests" title="Permalink to this headline">¶</a></h3>
<p>You can write test functions and methods like this:</p>
<div class="highlight-python"><pre>def test_something(space):
    # use space ...

class TestSomething(object):
    def test_some(self):
        # use 'self.space' here</pre>
</div>
<p>Note that the prefix <cite>test</cite> for test functions and <cite>Test</cite> for test
classes is mandatory.  In both cases you can import Python modules at
module global level and use plain &#8216;assert&#8217; statements thanks to the
usage of the <a class="reference external" href="http://pytest.org/">py.test</a> tool.</p>
</div>
<div class="section" id="application-level-tests">
<h3><a class="toc-backref" href="#id49">Application Level tests</a><a class="headerlink" href="#application-level-tests" title="Permalink to this headline">¶</a></h3>
<p>For testing the conformance and well-behavedness of PyPy it
is often sufficient to write &#8220;normal&#8221; application-level
Python code that doesn&#8217;t need to be aware of any particular
coding style or restrictions.  If we have a choice we often
use application level tests which usually look like this:</p>
<div class="highlight-python"><pre>def app_test_something():
    # application level test code

class AppTestSomething(object):
    def test_this(self):
        # application level test code</pre>
</div>
<p>These application level test functions will run on top
of PyPy, i.e. they have no access to interpreter details.
You cannot use imported modules from global level because
they are imported at interpreter-level while you test code
runs at application level. If you need to use modules
you have to import them within the test function.</p>
<p>Data can be passed into the AppTest using
the <tt class="docutils literal"><span class="pre">setup_class</span></tt> method of the AppTest. All wrapped objects that are
attached to the class there and start with <tt class="docutils literal"><span class="pre">w_</span></tt> can be accessed
via self (but without the <tt class="docutils literal"><span class="pre">w_</span></tt>) in the actual test method. An example:</p>
<div class="highlight-python"><pre>class AppTestErrno(object):
    def setup_class(cls):
        cls.w_d = cls.space.wrap({"a": 1, "b", 2})

    def test_dict(self):
        assert self.d["a"] == 1
        assert self.d["b"] == 2</pre>
</div>
<p id="run-the-tests-as-usual">Another possibility is to use cls.space.appexec, for example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">AppTestSomething</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">setup_class</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="n">arg</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">w_result</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">appexec</span><span class="p">([</span><span class="n">cls</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">arg</span><span class="p">)],</span> <span class="s">&quot;&quot;&quot;(arg):</span>
<span class="s">            return arg ** 6</span>
<span class="s">            &quot;&quot;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_power</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">6</span>
</pre></div>
</div>
<p>which executes the code string function with the given arguments at app level.
Note the use of <tt class="docutils literal"><span class="pre">w_result</span></tt> in <tt class="docutils literal"><span class="pre">setup_class</span></tt> but self.result in the test
Here is how to define an app level class  in <tt class="docutils literal"><span class="pre">setup_class</span></tt> that can be used
in subsequent tests:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">AppTestSet</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">setup_class</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="n">w_fakeint</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">appexec</span><span class="p">([],</span> <span class="s">&quot;&quot;&quot;():</span>
<span class="s">            class FakeInt(object):</span>
<span class="s">                def __init__(self, value):</span>
<span class="s">                    self.value = value</span>
<span class="s">                def __hash__(self):</span>
<span class="s">                    return hash(self.value)</span>

<span class="s">                def __eq__(self, other):</span>
<span class="s">                    if other == self.value:</span>
<span class="s">                        return True</span>
<span class="s">                    return False</span>
<span class="s">            return FakeInt</span>
<span class="s">            &quot;&quot;&quot;</span><span class="p">)</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">w_FakeInt</span> <span class="o">=</span> <span class="n">w_fakeint</span>

    <span class="k">def</span> <span class="nf">test_fakeint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">f1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FakeInt</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">f1</span> <span class="o">==</span> <span class="mi">4</span>
        <span class="k">assert</span> <span class="nb">hash</span><span class="p">(</span><span class="n">f1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="command-line-tool-test-all">
<h3><a class="toc-backref" href="#id50">Command line tool test_all</a><a class="headerlink" href="#command-line-tool-test-all" title="Permalink to this headline">¶</a></h3>
<p>You can run almost all of PyPy&#8217;s tests by invoking:</p>
<div class="highlight-python"><pre>python test_all.py file_or_directory</pre>
</div>
<p>which is a synonym for the general <a class="reference external" href="http://pytest.org/">py.test</a> utility
located in the <tt class="docutils literal"><span class="pre">py/bin/</span></tt> directory.  For switches to
modify test execution pass the <tt class="docutils literal"><span class="pre">-h</span></tt> option.</p>
</div>
<div class="section" id="coverage-reports">
<h3><a class="toc-backref" href="#id51">Coverage reports</a><a class="headerlink" href="#coverage-reports" title="Permalink to this headline">¶</a></h3>
<p>In order to get coverage reports the <a class="reference external" href="http://pypi.python.org/pypi/pytest-cov">pytest-cov</a> plugin is included.
it adds some extra requirements ( <a class="reference external" href="http://pypi.python.org/pypi/coverage">coverage</a> and <a class="reference external" href="http://pypi.python.org/pypi/cov-core">cov-core</a> )
and can once they are installed coverage testing can be invoked via:</p>
<div class="highlight-python"><pre>python test_all.py --cov file_or_direcory_to_cover file_or_directory</pre>
</div>
</div>
<div class="section" id="test-conventions">
<h3><a class="toc-backref" href="#id52">Test conventions</a><a class="headerlink" href="#test-conventions" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>adding features requires adding appropriate tests.  (It often even
makes sense to first write the tests so that you are sure that they
actually can fail.)</li>
<li>All over the pypy source code there are test/ directories
which contain unit tests.  Such scripts can usually be executed
directly or are collectively run by pypy/test_all.py</li>
</ul>
</div>
</div>
<div class="section" id="changing-documentation-and-website">
<span id="change-documentation-and-website"></span><h2><a class="toc-backref" href="#id53">Changing documentation and website</a><a class="headerlink" href="#changing-documentation-and-website" title="Permalink to this headline">¶</a></h2>
<div class="section" id="documentation-website-files-in-your-local-checkout">
<h3><a class="toc-backref" href="#id54">documentation/website files in your local checkout</a><a class="headerlink" href="#documentation-website-files-in-your-local-checkout" title="Permalink to this headline">¶</a></h3>
<p>Most of the PyPy&#8217;s documentation is kept in <cite>pypy/doc</cite>.
You can simply edit or add &#8216;.rst&#8217; files which contain ReST-markuped
files.  Here is a <a class="reference external" href="http://docutils.sourceforge.net/docs/user/rst/quickref.html">ReST quickstart</a> but you can also just look
at the existing documentation and see how things work.</p>
<p>Note that the web site of <a class="reference external" href="http://pypy.org/">http://pypy.org/</a> is maintained separately.
For now it is in the repository <a class="reference external" href="https://bitbucket.org/pypy/pypy.org">https://bitbucket.org/pypy/pypy.org</a></p>
</div>
<div class="section" id="automatically-test-documentation-website-changes">
<h3><a class="toc-backref" href="#id55">Automatically test documentation/website changes</a><a class="headerlink" href="#automatically-test-documentation-website-changes" title="Permalink to this headline">¶</a></h3>
<p>We automatically check referential integrity and ReST-conformance.  In order to
run the tests you need <a class="reference external" href="http://sphinx.pocoo.org/">sphinx</a> installed.  Then go to the local checkout
of the documentation directory and run the Makefile:</p>
<div class="highlight-python"><pre>cd pypy/doc
make html</pre>
</div>
<p>If you see no failures chances are high that your modifications at least
don&#8217;t produce ReST-errors or wrong local references. Now you will have <cite>.html</cite>
files in the documentation directory which you can point your browser to!</p>
<p>Additionally, if you also want to check for remote references inside
the documentation issue:</p>
<div class="highlight-python"><pre>make linkcheck</pre>
</div>
<p>which will check that remote URLs are reachable.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Coding Guide</a><ul>
<li><a class="reference internal" href="#overview-and-motivation">Overview and motivation</a><ul>
<li><a class="reference internal" href="#cpython-vs-pypy">CPython vs. PyPy</a></li>
<li><a class="reference internal" href="#application-level-and-interpreter-level-execution-and-objects">Application-level and interpreter-level execution and objects</a></li>
<li><a class="reference internal" href="#application-level-is-often-preferable">Application level is often preferable</a></li>
<li><a class="reference internal" href="#our-runtime-interpreter-is-rpython">Our runtime interpreter is &#8220;RPython&#8221;</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id1">RPython</a><ul>
<li><a class="reference internal" href="#rpython-definition">RPython Definition</a></li>
<li><a class="reference internal" href="#flow-restrictions">Flow restrictions</a></li>
<li><a class="reference internal" href="#object-restrictions">Object restrictions</a></li>
<li><a class="reference internal" href="#integer-types">Integer Types</a></li>
<li><a class="reference internal" href="#exception-rules">Exception rules</a></li>
<li><a class="reference internal" href="#pypy-is-debuggable-on-top-of-cpython">PyPy is debuggable on top of CPython</a></li>
</ul>
</li>
<li><a class="reference internal" href="#wrapped">Wrapping rules</a><ul>
<li><a class="reference internal" href="#wrapping">Wrapping</a></li>
<li><a class="reference internal" href="#naming-conventions">Naming conventions</a></li>
<li><a class="reference internal" href="#operations-on-w-xxx">Operations on <tt class="docutils literal"><span class="pre">w_xxx</span></tt></a></li>
<li><a class="reference internal" href="#application-level-exceptions">Application-level exceptions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#modules-in-pypy">Modules in PyPy</a><ul>
<li><a class="reference internal" href="#determining-the-location-of-a-module-implementation">Determining the location of a module implementation</a></li>
<li><a class="reference internal" href="#module-directories-import-order">Module directories / Import order</a></li>
<li><a class="reference internal" href="#modifying-a-cpython-library-module-or-regression-test">Modifying a CPython library module or regression test</a></li>
<li><a class="reference internal" href="#implementing-a-mixed-interpreter-application-level-module">Implementing a mixed interpreter/application level Module</a><ul>
<li><a class="reference internal" href="#application-level-definitions">application level definitions</a></li>
<li><a class="reference internal" href="#interpreter-level-definitions">interpreter level definitions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#testing-modules-in-lib-pypy">Testing modules in <tt class="docutils literal"><span class="pre">lib_pypy/</span></tt></a></li>
<li><a class="reference internal" href="#testing-modules-in-pypy-module">Testing modules in <tt class="docutils literal"><span class="pre">pypy/module</span></tt></a></li>
<li><a class="reference internal" href="#testing-modules-in-lib-python">Testing modules in <tt class="docutils literal"><span class="pre">lib-python</span></tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#naming-conventions-and-directory-layout">Naming conventions and directory layout</a><ul>
<li><a class="reference internal" href="#directory-and-file-naming">Directory and File Naming</a></li>
<li><a class="reference internal" href="#naming-of-python-objects">Naming of python objects</a></li>
<li><a class="reference internal" href="#committing-branching-to-the-repository">Committing &amp; Branching to the repository</a></li>
</ul>
</li>
<li><a class="reference internal" href="#using-the-development-bug-feature-tracker">Using the development bug/feature tracker</a><ul>
<li><a class="reference internal" href="#use-your-codespeak-login-or-register">use your codespeak login or register</a></li>
</ul>
</li>
<li><a class="reference internal" href="#test-design">Testing in PyPy</a><ul>
<li><a class="reference internal" href="#interpreter-level-tests">Interpreter level tests</a></li>
<li><a class="reference internal" href="#application-level-tests">Application Level tests</a></li>
<li><a class="reference internal" href="#command-line-tool-test-all">Command line tool test_all</a></li>
<li><a class="reference internal" href="#coverage-reports">Coverage reports</a></li>
<li><a class="reference internal" href="#test-conventions">Test conventions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#changing-documentation-and-website">Changing documentation and website</a><ul>
<li><a class="reference internal" href="#documentation-website-files-in-your-local-checkout">documentation/website files in your local checkout</a></li>
<li><a class="reference internal" href="#automatically-test-documentation-website-changes">Automatically test documentation/website changes</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/coding-guide.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li><a href="index.html">PyPy 2.2.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, The PyPy Project.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>