

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>The RPython Typer &mdash; PyPy 2.2.0 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '2.2.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="PyPy 2.2.0 documentation" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li><a href="index.html">PyPy 2.2.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="the-rpython-typer">
<h1><a class="toc-backref" href="#id10">The RPython Typer</a><a class="headerlink" href="#the-rpython-typer" title="Permalink to this headline">¶</a></h1>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#the-rpython-typer" id="id10">The RPython Typer</a><ul>
<li><a class="reference internal" href="#overview" id="id11">Overview</a></li>
<li><a class="reference internal" href="#example-integer-operations" id="id12">Example: Integer operations</a></li>
<li><a class="reference internal" href="#the-process-in-more-details" id="id13">The process in more details</a></li>
<li><a class="reference internal" href="#representations" id="id14">Representations</a></li>
<li><a class="reference internal" href="#low-level-types" id="id15">Low-Level Types</a><ul>
<li><a class="reference internal" href="#primitive-types" id="id16">Primitive Types</a></li>
<li><a class="reference internal" href="#structure-types" id="id17">Structure Types</a></li>
<li><a class="reference internal" href="#array-types" id="id18">Array Types</a></li>
<li><a class="reference internal" href="#pointer-types" id="id19">Pointer Types</a></li>
<li><a class="reference internal" href="#function-types" id="id20">Function Types</a></li>
<li><a class="reference internal" href="#the-pyobject-type" id="id21">The PyObject Type</a></li>
<li><a class="reference internal" href="#opaque-types" id="id22">Opaque Types</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementing-rpython-types" id="id23">Implementing RPython types</a></li>
<li><a class="reference internal" href="#highlevelop-interface" id="id24">HighLevelOp interface</a></li>
<li><a class="reference internal" href="#the-llinterpreter" id="id25">The LLInterpreter</a></li>
</ul>
</li>
</ul>
</div>
<p>The RPython Typer lives in the directory <a class="reference external" href="https://bitbucket.org/pypy/pypy/src/default/rpython/rtyper/">rpython/rtyper/</a>.</p>
<div class="section" id="overview">
<h2><a class="toc-backref" href="#id11">Overview</a><a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>The RPython Typer is the bridge between the <a class="reference external" href="translation.html#the-annotation-pass">Annotator</a> and the low-level code
generators.  The annotations of the <a class="reference external" href="translation.html#the-annotation-pass">Annotator</a> are high-level, in the sense
that they describe RPython types like lists or instances of user-defined
classes.  In general, though, to emit code we need to represent these
high-level annotations in the low-level model of the target language; for C,
this means structures and pointers and arrays.  The Typer both determines the
appropriate low-level type for each annotation, and tries to replace <em>all</em>
operations in the control flow graphs with one or a few low-level operations.
Just like low-level types, there is only a fairly restricted set of low-level
operations, along the lines of reading or writing from or to a field of a
structure.</p>
<p>In theory, this step is optional; some code generators might be able to read
the high-level types directly.  However, we expect that case to be the
exception.  &#8220;Compiling&#8221; high-level types into low-level ones is rather more
messy than one would expect.  This was the motivation for making this step
explicit and isolated in a single place.  After Typing, the graphs can only
contain very few operations, which makes the job of the code generators much
simpler.</p>
</div>
<div class="section" id="example-integer-operations">
<h2><a class="toc-backref" href="#id12">Example: Integer operations</a><a class="headerlink" href="#example-integer-operations" title="Permalink to this headline">¶</a></h2>
<p>Integer operations are the easiest.  Assume a graph containing the following
operation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">v3</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>
</pre></div>
</div>
<p>annotated:</p>
<div class="highlight-python"><pre>v1 -&gt; SomeInteger()
v2 -&gt; SomeInteger()
v3 -&gt; SomeInteger()</pre>
</div>
<p>then obviously we want to type it and replace it with:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">v3</span> <span class="o">=</span> <span class="n">int_add</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>
</pre></div>
</div>
<p>where &#8211; in C notation &#8211; all three variables v1, v2 and v3 are typed <tt class="docutils literal"><span class="pre">int</span></tt>.
This is done by attaching an attribute <tt class="docutils literal"><span class="pre">concretetype</span></tt> to v1, v2 and v3
(which might be instances of Variable or possibly Constant).  In our model,
this <tt class="docutils literal"><span class="pre">concretetype</span></tt> is <tt class="docutils literal"><span class="pre">rpython.rtyper.lltypesystem.lltype.Signed</span></tt>.  Of
course, the purpose of replacing the operation called <tt class="docutils literal"><span class="pre">add</span></tt> with
<tt class="docutils literal"><span class="pre">int_add</span></tt> is that code generators no longer have to worry about what kind
of addition (or concatenation maybe?) it means.</p>
</div>
<div class="section" id="the-process-in-more-details">
<h2><a class="toc-backref" href="#id13">The process in more details</a><a class="headerlink" href="#the-process-in-more-details" title="Permalink to this headline">¶</a></h2>
<p>The RPython Typer has a structure similar to that of the <a class="reference external" href="translation.html#the-annotation-pass">Annotator</a>: both
consider each block of the flow graphs in turn, and perform some analysis on
each operation.  In both cases the analysis of an operation depends on the
annotations of its input arguments.  This is reflected in the usage of the same
<tt class="docutils literal"><span class="pre">__extend__</span></tt> syntax in the source files (compare e.g.
<a class="reference external" href="https://bitbucket.org/pypy/pypy/src/default/rpython/annotator/binaryop.py">rpython/annotator/binaryop.py</a> and <a class="reference external" href="https://bitbucket.org/pypy/pypy/src/default/rpython/rtyper/rint.py">rpython/rtyper/rint.py</a>).</p>
<p>The analogy stops here, though: while it runs, the Annotator is in the middle
of computing the annotations, so it might need to reflow and generalize until
a fixpoint is reached.  The Typer, by contrast, works on the final annotations
that the Annotator computed, without changing them, assuming that they are
globally consistent.  There is no need to reflow: the Typer considers each
block only once.  And unlike the Annotator, the Typer completely modifies the
flow graph, by replacing each operation with some low-level operations.</p>
<p>In addition to replacing operations, the RTyper creates a <tt class="docutils literal"><span class="pre">concretetype</span></tt>
attribute on all Variables and Constants in the flow graphs, which tells code
generators which type to use for each of them.  This attribute is a
<a class="reference internal" href="#low-level-type">low-level type</a>, as described below.</p>
</div>
<div class="section" id="representations">
<h2><a class="toc-backref" href="#id14">Representations</a><a class="headerlink" href="#representations" title="Permalink to this headline">¶</a></h2>
<p>Representations &#8211; the Repr classes &#8211; are the most important internal classes
used by the RTyper.  (They are internal in the sense that they are an
&#8220;implementation detail&#8221; and their instances just go away after the RTyper is
finished; the code generators should only use the <tt class="docutils literal"><span class="pre">concretetype</span></tt> attributes,
which are not Repr instances but <a class="reference internal" href="#low-level-types">low-level types</a>.)</p>
<p>A representation contains all the logic about mapping a specific SomeXxx()
annotation to a specific low-level type.  For the time being, the RTyper
assumes that each SomeXxx() instance needs only one &#8220;canonical&#8221; representation.
For example, all variables annotated with SomeInteger() will correspond to the
<tt class="docutils literal"><span class="pre">Signed</span></tt> low-level type via the <tt class="docutils literal"><span class="pre">IntegerRepr</span></tt> representation.  More subtly,
variables annotated SomeList() can correspond either to a structure holding an
array of items of the correct type, or &#8211; if the list in question is just a
range() with a constant step &#8211; a structure with just start and stop fields.</p>
<p>This example shows that two representations may need very different low-level
implementations for the same high-level operations.  This is the reason for
turning representations into explicit objects.</p>
<p>The base Repr class is defined in <a class="reference external" href="https://bitbucket.org/pypy/pypy/src/default/rpython/rtyper/rmodel.py">rpython/rtyper/rmodel.py</a>.  Most of the
<tt class="docutils literal"><span class="pre">rpython/r*.py</span></tt> files define one or a few subclasses of Repr.  The method
getrepr() of the RTyper will build and cache a single Repr instance per
SomeXxx() instance; moreover, two SomeXxx() instances that are equal get the
same Repr instance.</p>
<p>The key attribute of a Repr instance is called <tt class="docutils literal"><span class="pre">lowleveltype</span></tt>, which is what
gets copied into the attribute <tt class="docutils literal"><span class="pre">concretetype</span></tt> of the Variables that have been
given this representation.  The RTyper also computes a <tt class="docutils literal"><span class="pre">concretetype</span></tt> for
Constants, to match the way they are used in the low-level operations (for
example, <tt class="docutils literal"><span class="pre">int_add(x,</span> <span class="pre">1)</span></tt> requires a <tt class="docutils literal"><span class="pre">Constant(1)</span></tt> with
<tt class="docutils literal"><span class="pre">concretetype=Signed</span></tt>, but an untyped <tt class="docutils literal"><span class="pre">add(x,</span> <span class="pre">1)</span></tt> works with a
<tt class="docutils literal"><span class="pre">Constant(1)</span></tt> that must actually be a PyObject at run-time).</p>
<p>In addition to <tt class="docutils literal"><span class="pre">lowleveltype</span></tt>, each Repr subclass provides a set of methods
called <tt class="docutils literal"><span class="pre">rtype_op_xxx()</span></tt> which define how each high-level operation <tt class="docutils literal"><span class="pre">op_xxx</span></tt>
is turned into low-level operations.</p>
</div>
<div class="section" id="low-level-types">
<span id="low-level-type"></span><h2><a class="toc-backref" href="#id15">Low-Level Types</a><a class="headerlink" href="#low-level-types" title="Permalink to this headline">¶</a></h2>
<p>The RPython Typer uses a standard low-level model which we believe can
correspond rather directly to various target languages such as C.
This model is implemented in the first part of
<a class="reference external" href="https://bitbucket.org/pypy/pypy/src/default/rpython/rtyper/lltypesystem/lltype.py">rpython/rtyper/lltypesystem/lltype.py</a>.</p>
<p>The second part of <a class="reference external" href="https://bitbucket.org/pypy/pypy/src/default/rpython/rtyper/lltypesystem/lltype.py">rpython/rtyper/lltypesystem/lltype.py</a> is a runnable
implementation of these types, for testing purposes.  It allows us to write
and test plain Python code using a malloc() function to obtain and manipulate
structures and arrays.  This is useful for example to implement and test
RPython types like &#8216;list&#8217; with its operations and methods.</p>
<p>The basic assumption is that Variables (i.e. local variables and function
arguments and return value) all contain &#8220;simple&#8221; values: basically, just
integers or pointers.  All the &#8220;container&#8221; data structures (struct and array)
are allocated in the heap, and they are always manipulated via pointers.
(There is no equivalent to the C notion of local variable of a <tt class="docutils literal"><span class="pre">struct</span></tt> type.)</p>
<p>Here is a quick tour:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">rpython.rtyper.lltypesystem.lltype</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
<p>Here are a few primitive low-level types, and the typeOf() function to figure
them out:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Signed</span>
<span class="go">&lt;Signed&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">typeOf</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">&lt;Signed&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">typeOf</span><span class="p">(</span><span class="n">r_uint</span><span class="p">(</span><span class="mi">12</span><span class="p">))</span>
<span class="go">&lt;Unsigned&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">typeOf</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
<span class="go">&lt;Char&gt;</span>
</pre></div>
</div>
<p>Let&#8217;s say that we want to build a type &#8220;point&#8221;, which is a structure with two
integer fields &#8220;x&#8221; and &#8220;y&#8221;:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">POINT</span> <span class="o">=</span> <span class="n">GcStruct</span><span class="p">(</span><span class="s">&#39;point&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">,</span> <span class="n">Signed</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;y&#39;</span><span class="p">,</span> <span class="n">Signed</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">POINT</span>
<span class="go">&lt;GcStruct point { x: Signed, y: Signed }&gt;</span>
</pre></div>
</div>
<p>The structure is a <tt class="docutils literal"><span class="pre">GcStruct</span></tt>, which means a structure that can be allocated
in the heap and eventually freed by some garbage collector.  (For platforms
where we use reference counting, think about <tt class="docutils literal"><span class="pre">GcStruct</span></tt> as a struct with an
additional reference counter field.)</p>
<p>Giving a name (&#8216;point&#8217;) to the GcStruct is only for clarity: it is used in the
representation.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">POINT</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span>
<span class="go">&lt;* struct point { x=0, y=0 }&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">x</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span>
<span class="go">&lt;* struct point { x=5, y=0 }&gt;</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">malloc()</span></tt> allocates a structure from the heap, initializes it to 0
(currently), and returns a pointer to it.  The point of all this is to work with
a very limited, easily controllable set of types, and define implementations of
types like list in this elementary world.  The <tt class="docutils literal"><span class="pre">malloc()</span></tt> function is a kind
of placeholder, which must eventually be provided by the code generator for the
target platform; but as we have just seen its Python implementation in
<a class="reference external" href="https://bitbucket.org/pypy/pypy/src/default/rpython/rtyper/lltypesystem/lltype.py">rpython/rtyper/lltypesystem/lltype.py</a> works too, which is primarily useful for
testing, interactive exploring, etc.</p>
<p>The argument to <tt class="docutils literal"><span class="pre">malloc()</span></tt> is the structure type directly, but it returns a
pointer to the structure, as <tt class="docutils literal"><span class="pre">typeOf()</span></tt> tells you:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">typeOf</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">&lt;* GcStruct point { x: Signed, y: Signed }&gt;</span>
</pre></div>
</div>
<p>For the purpose of creating structures with pointers to other structures, we can
declare pointer types explicitly:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">typeOf</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="n">Ptr</span><span class="p">(</span><span class="n">POINT</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BIZARRE</span> <span class="o">=</span> <span class="n">GcStruct</span><span class="p">(</span><span class="s">&#39;bizarre&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s">&#39;p1&#39;</span><span class="p">,</span> <span class="n">Ptr</span><span class="p">(</span><span class="n">POINT</span><span class="p">)),</span> <span class="p">(</span><span class="s">&#39;p2&#39;</span><span class="p">,</span> <span class="n">Ptr</span><span class="p">(</span><span class="n">POINT</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">BIZARRE</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">p1</span>
<span class="go">&lt;* None&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">p1</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">p2</span> <span class="o">=</span> <span class="n">p</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">p1</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">p2</span><span class="o">.</span><span class="n">y</span>
<span class="go">42</span>
</pre></div>
</div>
<p>The world of low-level types is more complicated than integers and GcStructs,
though.  The next pages are a reference guide.</p>
<div class="section" id="primitive-types">
<h3><a class="toc-backref" href="#id16">Primitive Types</a><a class="headerlink" href="#primitive-types" title="Permalink to this headline">¶</a></h3>
<dl class="docutils">
<dt>Signed</dt>
<dd>a signed integer in one machine word (a <tt class="docutils literal"><span class="pre">long</span></tt>, in C)</dd>
<dt>Unsigned</dt>
<dd>a non-signed integer in one machine word (<tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span></tt>)</dd>
<dt>Float</dt>
<dd>a 64-bit float (<tt class="docutils literal"><span class="pre">double</span></tt>)</dd>
<dt>Char</dt>
<dd>a single character (<tt class="docutils literal"><span class="pre">char</span></tt>)</dd>
<dt>Bool</dt>
<dd>a boolean value</dd>
<dt>Void</dt>
<dd>a constant.  Meant for variables, function arguments, structure fields, etc.
which should disappear from the generated code.</dd>
</dl>
</div>
<div class="section" id="structure-types">
<h3><a class="toc-backref" href="#id17">Structure Types</a><a class="headerlink" href="#structure-types" title="Permalink to this headline">¶</a></h3>
<p>Structure types are built as instances of
<tt class="docutils literal"><span class="pre">rpython.rtyper.lltypesystem.lltype.Struct</span></tt>:</p>
<div class="highlight-python"><pre>MyStructType = Struct('somename',  ('field1', Type1), ('field2', Type2)...)
MyStructType = GcStruct('somename',  ('field1', Type1), ('field2', Type2)...)</pre>
</div>
<p>This declares a structure (or a Pascal <tt class="docutils literal"><span class="pre">record</span></tt>) containing the specified
named fields with the given types.  The field names cannot start with an
underscore.  As noted above, you cannot directly manipulate structure objects,
but only pointer to structures living in the heap.</p>
<p>By contrast, the fields themselves can be of primitive, pointer or container
type.  When a structure contains another structure as a field we say that the
latter is &#8220;inlined&#8221; in the former: the bigger structure contains the smaller one
as part of its memory layout.</p>
<p>A structure can also contain an inlined array (see below), but only as its last
field: in this case it is a &#8220;variable-sized&#8221; structure, whose memory layout
starts with the non-variable fields and ends with a variable number of array
items.  This number is determined when a structure is allocated in the heap.
Variable-sized structures cannot be inlined in other structures.</p>
<p>GcStructs have a platform-specific GC header (e.g. a reference counter); only
these can be dynamically malloc()ed.  The non-GC version of Struct does not have
any header, and is suitable for being embedded (&#8220;inlined&#8221;) inside other
structures.  As an exception, a GcStruct can be embedded as the first field of a
GcStruct: the parent structure uses the same GC header as the substructure.</p>
</div>
<div class="section" id="array-types">
<h3><a class="toc-backref" href="#id18">Array Types</a><a class="headerlink" href="#array-types" title="Permalink to this headline">¶</a></h3>
<p>An array type is built as an instance of
<tt class="docutils literal"><span class="pre">rpython.rtyper.lltypesystem.lltype.Array</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">MyIntArray</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="n">Signed</span><span class="p">)</span>
<span class="n">MyOtherArray</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="n">MyItemType</span><span class="p">)</span>
<span class="n">MyOtherArray</span> <span class="o">=</span> <span class="n">GcArray</span><span class="p">(</span><span class="n">MyItemType</span><span class="p">)</span>
</pre></div>
</div>
<p>Or, for arrays whose items are structures, as a shortcut:</p>
<div class="highlight-python"><pre>MyArrayType = Array(('field1', Type1), ('field2', Type2)...)</pre>
</div>
<p>You can build arrays whose items are either primitive or pointer types, or
(non-GC non-varsize) structures.</p>
<p>GcArrays can be malloc()ed.  The length must be specified when malloc() is
called, and arrays cannot be resized; this length is stored explicitly in a
header.</p>
<p>The non-GC version of Array can be used as the last field of a structure, to
make a variable-sized structure.  The whole structure can then be malloc()ed,
and the length of the array is specified at this time.</p>
</div>
<div class="section" id="pointer-types">
<h3><a class="toc-backref" href="#id19">Pointer Types</a><a class="headerlink" href="#pointer-types" title="Permalink to this headline">¶</a></h3>
<p>As in C, pointers provide the indirection needed to make a reference modifiable
or sharable.  Pointers can only point to a structure, an array, a function
(see below) or a PyObject (see below).  Pointers to primitive types, if needed,
must be done by pointing to a structure with a single field of the required
type.  Pointer types are declared by:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Ptr</span><span class="p">(</span><span class="n">TYPE</span><span class="p">)</span>
</pre></div>
</div>
<p>At run-time, pointers to GC structures (GcStruct, GcArray and PyObject) hold a
reference to what they are pointing to.  Pointers to non-GC structures that can
go away when their container is deallocated (Struct, Array) must be handled
with care: the bigger structure of which they are part of could be freed while
the Ptr to the substructure is still in use.  In general, it is a good idea to
avoid passing around pointers to inlined substructures of malloc()ed structures.
(The testing implementation of <a class="reference external" href="https://bitbucket.org/pypy/pypy/src/default/rpython/rtyper/lltypesystem/lltype.py">rpython/rtyper/lltypesystem/lltype.py</a> checks to some
extent that you are not trying to use a pointer to a structure after its
container has been freed, using weak references.  But pointers to non-GC
structures are not officially meant to be weak references: using them after what
they point to has been freed just crashes.)</p>
<p>The malloc() operation allocates and returns a Ptr to a new GC structure or
array.  In a refcounting implementation, malloc() would allocate enough space
for a reference counter before the actual structure, and initialize it to 1.
Note that the testing implementation also allows malloc() to allocate a non-GC
structure or array with a keyword argument <tt class="docutils literal"><span class="pre">immortal=True</span></tt>.  Its purpose is to
declare and initialize prebuilt data structures which the code generators will
turn into static immortal non-GC&#8217;ed data.</p>
</div>
<div class="section" id="function-types">
<h3><a class="toc-backref" href="#id20">Function Types</a><a class="headerlink" href="#function-types" title="Permalink to this headline">¶</a></h3>
<p>The declaration:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">MyFuncType</span> <span class="o">=</span> <span class="n">FuncType</span><span class="p">([</span><span class="n">Type1</span><span class="p">,</span> <span class="n">Type2</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">ResultType</span><span class="p">)</span>
</pre></div>
</div>
<p>declares a function type taking arguments of the given types and returning a
result of the given type.  All these types must be primitives or pointers.  The
function type itself is considered to be a &#8220;container&#8221; type: if you wish, a
function contains the bytes that make up its executable code.  As with
structures and arrays, they can only be manipulated through pointers.</p>
<p>The testing implementation allows you to &#8220;create&#8221; functions by calling
<tt class="docutils literal"><span class="pre">functionptr(TYPE,</span> <span class="pre">name,</span> <span class="pre">**attrs)</span></tt>.  The extra attributes describe the
function in a way that isn&#8217;t fully specified now, but the following attributes
<em>might</em> be present:</p>
<blockquote>
<div><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">_callable:</th><td class="field-body">a Python callable, typically a function object.</td>
</tr>
<tr class="field-even field"><th class="field-name">graph:</th><td class="field-body">the flow graph of the function.</td>
</tr>
</tbody>
</table>
</div></blockquote>
</div>
<div class="section" id="the-pyobject-type">
<h3><a class="toc-backref" href="#id21">The PyObject Type</a><a class="headerlink" href="#the-pyobject-type" title="Permalink to this headline">¶</a></h3>
<p>This is a special type, for compatibility with CPython: it stands for a
structure compatible with PyObject.  This is also a &#8220;container&#8221; type (thinking
about C, this is <tt class="docutils literal"><span class="pre">PyObject</span></tt>, not <tt class="docutils literal"><span class="pre">PyObject*</span></tt>), so it is usually manipulated
via a Ptr.  A typed graph can still contain generic space operations (add,
getitem, etc.) provided they are applied on objects whose low-level type is
<tt class="docutils literal"><span class="pre">Ptr(PyObject)</span></tt>.  In fact, code generators that support this should consider
that the default type of a variable, if none is specified, is <tt class="docutils literal"><span class="pre">Ptr(PyObject)</span></tt>.
In this way, they can generate the correct code for fully-untyped flow graphs.</p>
<p>The testing implementation allows you to &#8220;create&#8221; PyObjects by calling
<tt class="docutils literal"><span class="pre">pyobjectptr(obj)</span></tt>.</p>
</div>
<div class="section" id="opaque-types">
<h3><a class="toc-backref" href="#id22">Opaque Types</a><a class="headerlink" href="#opaque-types" title="Permalink to this headline">¶</a></h3>
<p>Opaque types represent data implemented in a back-end specific way.  This
data cannot be inspected or manipulated.</p>
<p>There is a predefined opaque type <tt class="docutils literal"><span class="pre">RuntimeTypeInfo</span></tt>; at run-time, a
value of type <tt class="docutils literal"><span class="pre">RuntimeTypeInfo</span></tt> represents a low-level type.  In
practice it is probably enough to be able to represent GcStruct and
GcArray types.  This is useful if we have a pointer of type <tt class="docutils literal"><span class="pre">Ptr(S)</span></tt>
which can at run-time point either to a malloc&#8217;ed <tt class="docutils literal"><span class="pre">S</span></tt> alone, or to the
<tt class="docutils literal"><span class="pre">S</span></tt> first field of a larger malloc&#8217;ed structure.  The information about
the exact larger type that it points to can be computed or passed around
as a <tt class="docutils literal"><span class="pre">Ptr(RuntimeTypeInfo)</span></tt>.  Pointer equality on
<tt class="docutils literal"><span class="pre">Ptr(RuntimeTypeInfo)</span></tt> can be used to check the type at run-time.</p>
<p>At the moment, for memory management purposes, some back-ends actually
require such information to be available at run-time in the following
situation: when a GcStruct has another GcStruct as its first field.  A
reference-counting back-end needs to be able to know when a pointer to the
smaller structure actually points to the larger one, so that it can also
decref the extra fields.  Depending on the situation, it is possible to
reconstruct this information without having to store a flag in each and
every instance of the smaller GcStruct.  For example, the instances of a
class hierarchy can be implemented by nested GcStructs, with instances of
subclasses extending instances of parent classes by embedding the parent
part of the instance as the first field.  In this case, there is probably
already a way to know the run-time class of the instance (e.g. a vtable
pointer), but the back-end cannot guess this.  This is the reason for
which <tt class="docutils literal"><span class="pre">RuntimeTypeInfo</span></tt> was originally introduced: just after the
GcStruct is created, the function attachRuntimeTypeInfo() should be called
to attach to the GcStruct a low-level function of signature
<tt class="docutils literal"><span class="pre">Ptr(GcStruct)</span> <span class="pre">-&gt;</span> <span class="pre">Ptr(RuntimeTypeInfo)</span></tt>.  This function will be compiled
by the back-end and automatically called at run-time.  In the above
example, it would follow the vtable pointer and fetch the opaque
<tt class="docutils literal"><span class="pre">Ptr(RuntimeTypeInfo)</span></tt> from the vtable itself.  (The reference-counting
GenC back-end uses a pointer to the deallocation function as the opaque
<tt class="docutils literal"><span class="pre">RuntimeTypeInfo</span></tt>.)</p>
</div>
</div>
<div class="section" id="implementing-rpython-types">
<h2><a class="toc-backref" href="#id23">Implementing RPython types</a><a class="headerlink" href="#implementing-rpython-types" title="Permalink to this headline">¶</a></h2>
<p>As hinted above, the RPython types (e.g. &#8216;list&#8217;) are implemented in some
&#8220;restricted-restricted Python&#8221; format by manipulating only low-level types, as
provided by the testing implementation of malloc() and friends.  What occurs
then is that the same (tested!) very-low-level Python code &#8211; which looks really
just like C &#8211; is then transformed into a flow graph and integrated with the
rest of the user program.  In other words, we replace an operation like <tt class="docutils literal"><span class="pre">add</span></tt>
between two variables annotated as SomeList, with a <tt class="docutils literal"><span class="pre">direct_call</span></tt> operation
invoking this very-low-level list concatenation.</p>
<p>This list concatenation flow graph is then annotated as usual, with one
difference: the annotator has to be taught about malloc() and the way the
pointer thus obtained can be manipulated.  This generates a flow graph which is
hopefully completely annotated with SomePtr() annotation.  Introduced just for
this case, SomePtr maps directly to a low-level pointer type.  This is the only
change needed to the Annotator to allow it to perform type inference of our
very-low-level snippets of code.</p>
<p>See for example <a class="reference external" href="https://bitbucket.org/pypy/pypy/src/default/rpython/rtyper/rlist.py">rpython/rtyper/rlist.py</a>.</p>
</div>
<div class="section" id="highlevelop-interface">
<h2><a class="toc-backref" href="#id24">HighLevelOp interface</a><a class="headerlink" href="#highlevelop-interface" title="Permalink to this headline">¶</a></h2>
<p>In the absence of more extensive documentation about how RPython types are
implemented, here is the interface and intended usage of the &#8216;hop&#8217;
argument that appears everywhere.  A &#8216;hop&#8217; is a HighLevelOp instance,
which represents a single high-level operation that must be turned into
one or several low-level operations.</p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">hop.llops</span></tt></dt>
<dd>A list-like object that records the low-level operations that
correspond to the current block&#8217;s high-level operations.</dd>
<dt><tt class="docutils literal"><span class="pre">hop.genop(opname,</span> <span class="pre">list_of_variables,</span> <span class="pre">resulttype=resulttype)</span></tt></dt>
<dd>Append a low-level operation to <tt class="docutils literal"><span class="pre">hop.llops</span></tt>.  The operation has
the given opname and arguments, and returns the given low-level
resulttype.  The arguments should come from the <tt class="docutils literal"><span class="pre">hop.input*()</span></tt>
functions described below.</dd>
<dt><tt class="docutils literal"><span class="pre">hop.gendirectcall(ll_function,</span> <span class="pre">var1,</span> <span class="pre">var2...)</span></tt></dt>
<dd>Like hop.genop(), but produces a <tt class="docutils literal"><span class="pre">direct_call</span></tt> operation that
invokes the given low-level function, which is automatically
annotated with low-level types based on the input arguments.</dd>
<dt><tt class="docutils literal"><span class="pre">hop.inputargs(r1,</span> <span class="pre">r2...)</span></tt></dt>
<dd>Reads the high-level Variables and Constants that are the
arguments of the operation, and convert them if needed so that
they have the specified representations.  You must provide as many
representations as the operation has arguments.  Returns a list of
(possibly newly converted) Variables and Constants.</dd>
<dt><tt class="docutils literal"><span class="pre">hop.inputarg(r,</span> <span class="pre">arg=i)</span></tt></dt>
<dd>Same as inputargs(), but only converts and returns the ith
argument.</dd>
<dt><tt class="docutils literal"><span class="pre">hop.inputconst(lltype,</span> <span class="pre">value)</span></tt></dt>
<dd>Returns a Constant with a low-level type and value.</dd>
</dl>
</div></blockquote>
<p>Manipulation of HighLevelOp instances (this is used e.g. to insert a
&#8216;self&#8217; implicit argument to translate method calls):</p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">hop.copy()</span></tt></dt>
<dd>Returns a fresh copy that can be manipulated with the functions
below.</dd>
<dt><tt class="docutils literal"><span class="pre">hop.r_s_popfirstarg()</span></tt></dt>
<dd>Removes the first argument of the high-level operation.  This
doesn&#8217;t really changes the source SpaceOperation, but modifies
&#8216;hop&#8217; in such a way that methods like inputargs() no longer see
the removed argument.</dd>
<dt><tt class="docutils literal"><span class="pre">hop.v_s_insertfirstarg(v_newfirstarg,</span> <span class="pre">s_newfirstarg)</span></tt></dt>
<dd>Insert an argument in front of the hop.  It must be specified by
a Variable (as in calls to hop.genop()) and a corresponding
annotation.</dd>
<dt><tt class="docutils literal"><span class="pre">hop.swap_fst_snd_args()</span></tt></dt>
<dd>Self-descriptive.</dd>
</dl>
</div></blockquote>
<p>Exception handling:</p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">hop.has_implicit_exception(cls)</span></tt></dt>
<dd>Checks if hop is in the scope of a branch catching the exception
&#8216;cls&#8217;.  This is useful for high-level operations like &#8216;getitem&#8217;
that have several low-level equivalents depending on whether they
should check for an IndexError or not.  Calling
has_implicit_exception() also has a side-effect: the rtyper
records that this exception is being taken care of explicitly.</dd>
<dt><tt class="docutils literal"><span class="pre">hop.exception_is_here()</span></tt></dt>
<dd>To be called with no argument just before a llop is generated.  It
means that the llop in question will be the one that should be
protected by the exception catching.  If has_implicit_exception()
was called before, then exception_is_here() verifies that <em>all</em>
except links in the graph have indeed been checked for with an
has_implicit_exception().  This is not verified if
has_implicit_exception() has never been called &#8211; useful for
&#8216;direct_call&#8217; and other operations that can just raise any exception.</dd>
<dt><tt class="docutils literal"><span class="pre">hop.exception_cannot_occur()</span></tt></dt>
<dd>The RTyper normally verifies that exception_is_here() was really
called once for each high-level operation that is in the scope of
exception-catching links.  By saying exception_cannot_occur(),
you say that after all this particular operation cannot raise
anything.  (It can be the case that unexpected exception links are
attached to flow graphs; e.g. any method call within a
<tt class="docutils literal"><span class="pre">try:finally:</span></tt> block will have an Exception branch to the finally
part, which only the RTyper can remove if exception_cannot_occur()
is called.)</dd>
</dl>
</div></blockquote>
</div>
<div class="section" id="the-llinterpreter">
<span id="llinterpreter"></span><h2><a class="toc-backref" href="#id25">The LLInterpreter</a><a class="headerlink" href="#the-llinterpreter" title="Permalink to this headline">¶</a></h2>
<p>The LLInterpreter is a simple piece of code that is able to interpret flow
graphs. This is very useful for testing purposes, especially if you work on
the RPython Typer. The most useful interface for it is the <tt class="docutils literal"><span class="pre">interpret</span></tt>
function in the file <a class="reference external" href="https://bitbucket.org/pypy/pypy/src/default/rpython/rtyper/test/test_llinterp.py">rpython/rtyper/test/test_llinterp.py</a>. It takes as
arguments a function and a list of arguments with which the function is
supposed to be called. Then it generates the flow graph, annotates it
according to the types of the arguments you passed to it and runs the
LLInterpreter on the result. Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_invert</span><span class="p">():</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">~</span><span class="n">x</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">interpret</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">])</span>
    <span class="k">assert</span> <span class="n">res</span> <span class="o">==</span> <span class="o">~</span><span class="mi">3</span>
</pre></div>
</div>
<p>Furthermore there is a function <tt class="docutils literal"><span class="pre">interpret_raises</span></tt> which behaves much like
<tt class="docutils literal"><span class="pre">py.test.raises</span></tt>. It takes an exception as a first argument, the function to
be called as a second and the list of function arguments as a third. Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_raise</span><span class="p">():</span>
    <span class="k">def</span> <span class="nf">raise_exception</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">42</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span>
        <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">43</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span>
        <span class="k">return</span> <span class="n">i</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">interpret</span><span class="p">(</span><span class="n">raise_exception</span><span class="p">,</span> <span class="p">[</span><span class="mi">41</span><span class="p">])</span>
    <span class="k">assert</span> <span class="n">res</span> <span class="o">==</span> <span class="mi">41</span>
    <span class="n">interpret_raises</span><span class="p">(</span><span class="ne">IndexError</span><span class="p">,</span> <span class="n">raise_exception</span><span class="p">,</span> <span class="p">[</span><span class="mi">42</span><span class="p">])</span>
    <span class="n">interpret_raises</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="n">raise_exception</span><span class="p">,</span> <span class="p">[</span><span class="mi">43</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">The RPython Typer</a><ul>
<li><a class="reference internal" href="#overview">Overview</a></li>
<li><a class="reference internal" href="#example-integer-operations">Example: Integer operations</a></li>
<li><a class="reference internal" href="#the-process-in-more-details">The process in more details</a></li>
<li><a class="reference internal" href="#representations">Representations</a></li>
<li><a class="reference internal" href="#low-level-types">Low-Level Types</a><ul>
<li><a class="reference internal" href="#primitive-types">Primitive Types</a></li>
<li><a class="reference internal" href="#structure-types">Structure Types</a></li>
<li><a class="reference internal" href="#array-types">Array Types</a></li>
<li><a class="reference internal" href="#pointer-types">Pointer Types</a></li>
<li><a class="reference internal" href="#function-types">Function Types</a></li>
<li><a class="reference internal" href="#the-pyobject-type">The PyObject Type</a></li>
<li><a class="reference internal" href="#opaque-types">Opaque Types</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementing-rpython-types">Implementing RPython types</a></li>
<li><a class="reference internal" href="#highlevelop-interface">HighLevelOp interface</a></li>
<li><a class="reference internal" href="#the-llinterpreter">The LLInterpreter</a></li>
</ul>
</li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/rtyper.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li><a href="index.html">PyPy 2.2.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, The PyPy Project.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>